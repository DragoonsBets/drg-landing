{"ast":null,"code":"import _extends from '@babel/runtime-corejs2/helpers/esm/extends';\nimport invariant from 'tiny-invariant';\nimport { getRect, getBox, withScroll, createBox, calculateBox } from 'css-box-model';\nimport _Object$keys from '@babel/runtime-corejs2/core-js/object/keys';\nimport memoizeOne from 'memoize-one';\nimport { applyMiddleware, createStore, compose, bindActionCreators } from 'redux';\nimport _Object$assign from '@babel/runtime-corejs2/core-js/object/assign';\nimport rafSchd from 'raf-schd';\nimport _inheritsLoose from '@babel/runtime-corejs2/helpers/esm/inheritsLoose';\nimport React, { PureComponent, Component, Fragment } from 'react';\nimport PropTypes from 'prop-types';\nimport { connect } from 'react-redux';\nimport { Motion, spring } from 'react-motion';\nvar vertical = {\n  direction: 'vertical',\n  line: 'y',\n  crossAxisLine: 'x',\n  start: 'top',\n  end: 'bottom',\n  size: 'height',\n  crossAxisStart: 'left',\n  crossAxisEnd: 'right',\n  crossAxisSize: 'width'\n};\nvar horizontal = {\n  direction: 'horizontal',\n  line: 'x',\n  crossAxisLine: 'y',\n  start: 'left',\n  end: 'right',\n  size: 'width',\n  crossAxisStart: 'top',\n  crossAxisEnd: 'bottom',\n  crossAxisSize: 'height'\n};\nvar origin = {\n  x: 0,\n  y: 0\n};\n\nvar add = function add(point1, point2) {\n  return {\n    x: point1.x + point2.x,\n    y: point1.y + point2.y\n  };\n};\n\nvar subtract = function subtract(point1, point2) {\n  return {\n    x: point1.x - point2.x,\n    y: point1.y - point2.y\n  };\n};\n\nvar isEqual = function isEqual(point1, point2) {\n  return point1.x === point2.x && point1.y === point2.y;\n};\n\nvar negate = function negate(point) {\n  return {\n    x: point.x !== 0 ? -point.x : 0,\n    y: point.y !== 0 ? -point.y : 0\n  };\n};\n\nvar absolute = function absolute(point) {\n  return {\n    x: Math.abs(point.x),\n    y: Math.abs(point.y)\n  };\n};\n\nvar patch = function patch(line, value, otherValue) {\n  var _ref;\n\n  if (otherValue === void 0) {\n    otherValue = 0;\n  }\n\n  return _ref = {}, _ref[line] = value, _ref[line === 'x' ? 'y' : 'x'] = otherValue, _ref;\n};\n\nvar distance = function distance(point1, point2) {\n  return Math.sqrt(Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2));\n};\n\nvar closest = function closest(target, points) {\n  return Math.min.apply(Math, points.map(function (point) {\n    return distance(target, point);\n  }));\n};\n\nvar apply = function apply(fn) {\n  return function (point) {\n    return {\n      x: fn(point.x),\n      y: fn(point.y)\n    };\n  };\n};\n\nvar offsetByPosition = function offsetByPosition(spacing, point) {\n  return {\n    top: spacing.top + point.y,\n    left: spacing.left + point.x,\n    bottom: spacing.bottom + point.y,\n    right: spacing.right + point.x\n  };\n};\n\nvar expandByPosition = function expandByPosition(spacing, position) {\n  return {\n    top: spacing.top - position.y,\n    left: spacing.left - position.x,\n    right: spacing.right + position.x,\n    bottom: spacing.bottom + position.y\n  };\n};\n\nvar getCorners = function getCorners(spacing) {\n  return [{\n    x: spacing.left,\n    y: spacing.top\n  }, {\n    x: spacing.right,\n    y: spacing.top\n  }, {\n    x: spacing.left,\n    y: spacing.bottom\n  }, {\n    x: spacing.right,\n    y: spacing.bottom\n  }];\n};\n\nvar getMaxScroll = function getMaxScroll(_ref) {\n  var scrollHeight = _ref.scrollHeight,\n      scrollWidth = _ref.scrollWidth,\n      height = _ref.height,\n      width = _ref.width;\n  var maxScroll = subtract({\n    x: scrollWidth,\n    y: scrollHeight\n  }, {\n    x: width,\n    y: height\n  });\n  var adjustedMaxScroll = {\n    x: Math.max(0, maxScroll.x),\n    y: Math.max(0, maxScroll.y)\n  };\n  return adjustedMaxScroll;\n};\n\nvar clip = function clip(frame, subject) {\n  var result = getRect({\n    top: Math.max(subject.top, frame.top),\n    right: Math.min(subject.right, frame.right),\n    bottom: Math.min(subject.bottom, frame.bottom),\n    left: Math.max(subject.left, frame.left)\n  });\n\n  if (result.width <= 0 || result.height <= 0) {\n    return null;\n  }\n\n  return result;\n};\n\nvar getDroppableDimension = function getDroppableDimension(_ref) {\n  var descriptor = _ref.descriptor,\n      isEnabled = _ref.isEnabled,\n      direction = _ref.direction,\n      client = _ref.client,\n      page = _ref.page,\n      closest$$1 = _ref.closest;\n\n  var scrollable = function () {\n    if (!closest$$1) {\n      return null;\n    }\n\n    var maxScroll = getMaxScroll({\n      scrollHeight: closest$$1.scrollHeight,\n      scrollWidth: closest$$1.scrollWidth,\n      height: closest$$1.client.paddingBox.height,\n      width: closest$$1.client.paddingBox.width\n    });\n    return {\n      framePageMarginBox: closest$$1.page.marginBox,\n      shouldClipSubject: closest$$1.shouldClipSubject,\n      scroll: {\n        initial: closest$$1.scroll,\n        current: closest$$1.scroll,\n        max: maxScroll,\n        diff: {\n          value: origin,\n          displacement: origin\n        }\n      }\n    };\n  }();\n\n  var subjectPageMarginBox = page.marginBox;\n  var clippedPageMarginBox = scrollable && scrollable.shouldClipSubject ? clip(scrollable.framePageMarginBox, subjectPageMarginBox) : subjectPageMarginBox;\n  var viewport = {\n    closestScrollable: scrollable,\n    subjectPageMarginBox: subjectPageMarginBox,\n    clippedPageMarginBox: clippedPageMarginBox\n  };\n  var dimension = {\n    descriptor: descriptor,\n    axis: direction === 'vertical' ? vertical : horizontal,\n    isEnabled: isEnabled,\n    client: client,\n    page: page,\n    viewport: viewport\n  };\n  return dimension;\n};\n\nvar scrollDroppable = function scrollDroppable(droppable, newScroll) {\n  !droppable.viewport.closestScrollable ? process.env.NODE_ENV !== \"production\" ? invariant(false) : invariant(false) : void 0;\n  var scrollable = droppable.viewport.closestScrollable;\n  var framePageMarginBox = scrollable.framePageMarginBox;\n  var scrollDiff = subtract(newScroll, scrollable.scroll.initial);\n  var scrollDisplacement = negate(scrollDiff);\n  var closestScrollable = {\n    framePageMarginBox: scrollable.framePageMarginBox,\n    shouldClipSubject: scrollable.shouldClipSubject,\n    scroll: {\n      initial: scrollable.scroll.initial,\n      current: newScroll,\n      diff: {\n        value: scrollDiff,\n        displacement: scrollDisplacement\n      },\n      max: scrollable.scroll.max\n    }\n  };\n  var displacedSubject = offsetByPosition(droppable.viewport.subjectPageMarginBox, scrollDisplacement);\n  var clippedPageMarginBox = closestScrollable.shouldClipSubject ? clip(framePageMarginBox, displacedSubject) : getRect(displacedSubject);\n  var viewport = {\n    closestScrollable: closestScrollable,\n    subjectPageMarginBox: droppable.viewport.subjectPageMarginBox,\n    clippedPageMarginBox: clippedPageMarginBox\n  };\n\n  var result = _extends({}, droppable, {\n    viewport: viewport\n  });\n\n  return result;\n};\n\nvar toDroppableMap = memoizeOne(function (droppables) {\n  return droppables.reduce(function (previous, current) {\n    previous[current.descriptor.id] = current;\n    return previous;\n  }, {});\n});\nvar toDraggableMap = memoizeOne(function (draggables) {\n  return draggables.reduce(function (previous, current) {\n    previous[current.descriptor.id] = current;\n    return previous;\n  }, {});\n});\nvar toDroppableList = memoizeOne(function (droppables) {\n  return _Object$keys(droppables).map(function (id) {\n    return droppables[id];\n  });\n});\nvar toDraggableList = memoizeOne(function (draggables) {\n  return _Object$keys(draggables).map(function (id) {\n    return draggables[id];\n  });\n});\nvar getDraggablesInsideDroppable = memoizeOne(function (droppable, draggables) {\n  return toDraggableList(draggables).filter(function (draggable) {\n    return droppable.descriptor.id === draggable.descriptor.droppableId;\n  }).sort(function (a, b) {\n    return a.descriptor.index - b.descriptor.index;\n  });\n});\n\nvar isWithin = function isWithin(lowerBound, upperBound) {\n  return function (value) {\n    return value <= upperBound && value >= lowerBound;\n  };\n};\n\nvar isPositionInFrame = function isPositionInFrame(frame) {\n  var isWithinVertical = isWithin(frame.top, frame.bottom);\n  var isWithinHorizontal = isWithin(frame.left, frame.right);\n  return function (point) {\n    return isWithinVertical(point.y) && isWithinVertical(point.y) && isWithinHorizontal(point.x) && isWithinHorizontal(point.x);\n  };\n};\n\nvar getRequiredGrowth = memoizeOne(function (draggable, draggables, droppable) {\n  var getResult = function getResult(existingSpace) {\n    var requiredSpace = draggable.page.marginBox[droppable.axis.size];\n\n    if (requiredSpace <= existingSpace) {\n      return null;\n    }\n\n    var requiredGrowth = patch(droppable.axis.line, requiredSpace - existingSpace);\n    return requiredGrowth;\n  };\n\n  var dimensions = getDraggablesInsideDroppable(droppable, draggables);\n\n  if (!dimensions.length) {\n    var _existingSpace = droppable.page.marginBox[droppable.axis.size];\n    return getResult(_existingSpace);\n  }\n\n  var endOfDraggables = dimensions[dimensions.length - 1].page.marginBox[droppable.axis.end];\n  var endOfDroppable = droppable.page.marginBox[droppable.axis.end];\n  var existingSpace = endOfDroppable - endOfDraggables;\n  return getResult(existingSpace);\n});\nvar getWithGrowth = memoizeOne(function (area, growth) {\n  return getRect(expandByPosition(area, growth));\n});\n\nvar getClippedRectWithPlaceholder = function getClippedRectWithPlaceholder(_ref) {\n  var draggable = _ref.draggable,\n      draggables = _ref.draggables,\n      droppable = _ref.droppable,\n      previousDroppableOverId = _ref.previousDroppableOverId;\n  var isHome = draggable.descriptor.droppableId === droppable.descriptor.id;\n  var wasOver = Boolean(previousDroppableOverId && previousDroppableOverId === droppable.descriptor.id);\n  var clippedPageMarginBox = droppable.viewport.clippedPageMarginBox;\n\n  if (!clippedPageMarginBox) {\n    return clippedPageMarginBox;\n  }\n\n  if (isHome || !wasOver) {\n    return clippedPageMarginBox;\n  }\n\n  var requiredGrowth = getRequiredGrowth(draggable, draggables, droppable);\n\n  if (!requiredGrowth) {\n    return clippedPageMarginBox;\n  }\n\n  var subjectWithGrowth = getWithGrowth(clippedPageMarginBox, requiredGrowth);\n  var closestScrollable = droppable.viewport.closestScrollable;\n\n  if (!closestScrollable) {\n    return subjectWithGrowth;\n  }\n\n  if (!closestScrollable.shouldClipSubject) {\n    return subjectWithGrowth;\n  }\n\n  return clip(closestScrollable.framePageMarginBox, subjectWithGrowth);\n};\n\nvar getDroppableOver = function getDroppableOver(_ref2) {\n  var target = _ref2.target,\n      draggable = _ref2.draggable,\n      draggables = _ref2.draggables,\n      droppables = _ref2.droppables,\n      previousDroppableOverId = _ref2.previousDroppableOverId;\n  var maybe = toDroppableList(droppables).filter(function (droppable) {\n    return droppable.isEnabled;\n  }).find(function (droppable) {\n    var withPlaceholder = getClippedRectWithPlaceholder({\n      draggable: draggable,\n      draggables: draggables,\n      droppable: droppable,\n      previousDroppableOverId: previousDroppableOverId\n    });\n\n    if (!withPlaceholder) {\n      return false;\n    }\n\n    return isPositionInFrame(withPlaceholder)(target);\n  });\n  return maybe ? maybe.descriptor.id : null;\n};\n\nvar noMovement = {\n  displaced: [],\n  amount: origin,\n  isBeyondStartPosition: false\n};\nvar noImpact = {\n  movement: noMovement,\n  direction: null,\n  destination: null\n};\nvar getDisplacementMap = memoizeOne(function (displaced) {\n  return displaced.reduce(function (map, displacement) {\n    map[displacement.draggableId] = displacement;\n    return map;\n  }, {});\n});\n\nvar isPartiallyVisibleThroughFrame = function isPartiallyVisibleThroughFrame(frame) {\n  var isWithinVertical = isWithin(frame.top, frame.bottom);\n  var isWithinHorizontal = isWithin(frame.left, frame.right);\n  return function (subject) {\n    var isContained = isWithinVertical(subject.top) && isWithinVertical(subject.bottom) && isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);\n\n    if (isContained) {\n      return true;\n    }\n\n    var isPartiallyVisibleVertically = isWithinVertical(subject.top) || isWithinVertical(subject.bottom);\n    var isPartiallyVisibleHorizontally = isWithinHorizontal(subject.left) || isWithinHorizontal(subject.right);\n    var isPartiallyContained = isPartiallyVisibleVertically && isPartiallyVisibleHorizontally;\n\n    if (isPartiallyContained) {\n      return true;\n    }\n\n    var isBiggerVertically = subject.top < frame.top && subject.bottom > frame.bottom;\n    var isBiggerHorizontally = subject.left < frame.left && subject.right > frame.right;\n    var isTargetBiggerThanFrame = isBiggerVertically && isBiggerHorizontally;\n\n    if (isTargetBiggerThanFrame) {\n      return true;\n    }\n\n    var isTargetBiggerOnOneAxis = isBiggerVertically && isPartiallyVisibleHorizontally || isBiggerHorizontally && isPartiallyVisibleVertically;\n    return isTargetBiggerOnOneAxis;\n  };\n};\n\nvar isTotallyVisibleThroughFrame = function isTotallyVisibleThroughFrame(frame) {\n  var isWithinVertical = isWithin(frame.top, frame.bottom);\n  var isWithinHorizontal = isWithin(frame.left, frame.right);\n  return function (subject) {\n    var isContained = isWithinVertical(subject.top) && isWithinVertical(subject.bottom) && isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);\n    return isContained;\n  };\n};\n\nvar isVisible = function isVisible(_ref) {\n  var target = _ref.target,\n      destination = _ref.destination,\n      viewport = _ref.viewport,\n      isVisibleThroughFrameFn = _ref.isVisibleThroughFrameFn;\n  var displacement = destination.viewport.closestScrollable ? destination.viewport.closestScrollable.scroll.diff.displacement : origin;\n  var withDisplacement = offsetByPosition(target, displacement);\n\n  if (!destination.viewport.clippedPageMarginBox) {\n    return false;\n  }\n\n  var isVisibleInDroppable = isVisibleThroughFrameFn(destination.viewport.clippedPageMarginBox)(withDisplacement);\n  var isVisibleInViewport = isVisibleThroughFrameFn(viewport)(withDisplacement);\n  return isVisibleInDroppable && isVisibleInViewport;\n};\n\nvar isPartiallyVisible = function isPartiallyVisible(_ref2) {\n  var target = _ref2.target,\n      destination = _ref2.destination,\n      viewport = _ref2.viewport;\n  return isVisible({\n    target: target,\n    destination: destination,\n    viewport: viewport,\n    isVisibleThroughFrameFn: isPartiallyVisibleThroughFrame\n  });\n};\n\nvar isTotallyVisible = function isTotallyVisible(_ref3) {\n  var target = _ref3.target,\n      destination = _ref3.destination,\n      viewport = _ref3.viewport;\n  return isVisible({\n    target: target,\n    destination: destination,\n    viewport: viewport,\n    isVisibleThroughFrameFn: isTotallyVisibleThroughFrame\n  });\n};\n\nvar getDisplacement = function getDisplacement(_ref) {\n  var draggable = _ref.draggable,\n      destination = _ref.destination,\n      previousImpact = _ref.previousImpact,\n      viewport = _ref.viewport;\n  var id = draggable.descriptor.id;\n  var map = getDisplacementMap(previousImpact.movement.displaced);\n  var isVisible = isPartiallyVisible({\n    target: draggable.page.marginBox,\n    destination: destination,\n    viewport: viewport\n  });\n\n  var shouldAnimate = function () {\n    if (!isVisible) {\n      return false;\n    }\n\n    var previous = map[id];\n\n    if (!previous) {\n      return true;\n    }\n\n    return previous.shouldAnimate;\n  }();\n\n  var displacement = {\n    draggableId: id,\n    isVisible: isVisible,\n    shouldAnimate: shouldAnimate\n  };\n  return displacement;\n};\n\nvar withDroppableScroll = function withDroppableScroll(droppable, point) {\n  var closestScrollable = droppable.viewport.closestScrollable;\n\n  if (!closestScrollable) {\n    return point;\n  }\n\n  return add(point, closestScrollable.scroll.diff.value);\n};\n\nvar inHomeList = function inHomeList(_ref) {\n  var pageBorderBoxCenter = _ref.pageBorderBoxCenter,\n      draggable = _ref.draggable,\n      home = _ref.home,\n      insideHome = _ref.insideHome,\n      previousImpact = _ref.previousImpact,\n      viewport = _ref.viewport;\n  var axis = home.axis;\n  var originalCenter = draggable.page.borderBox.center;\n  var currentCenter = withDroppableScroll(home, pageBorderBoxCenter);\n  var isBeyondStartPosition = currentCenter[axis.line] - originalCenter[axis.line] > 0;\n  var amount = patch(axis.line, draggable.client.marginBox[axis.size]);\n  var displaced = insideHome.filter(function (child) {\n    if (child === draggable) {\n      return false;\n    }\n\n    var borderBox = child.page.borderBox;\n\n    if (isBeyondStartPosition) {\n      if (borderBox.center[axis.line] < originalCenter[axis.line]) {\n        return false;\n      }\n\n      return currentCenter[axis.line] > borderBox[axis.start];\n    }\n\n    if (originalCenter[axis.line] < borderBox.center[axis.line]) {\n      return false;\n    }\n\n    return currentCenter[axis.line] < borderBox[axis.end];\n  }).map(function (dimension) {\n    return getDisplacement({\n      draggable: dimension,\n      destination: home,\n      previousImpact: previousImpact,\n      viewport: viewport.frame\n    });\n  });\n  var ordered = isBeyondStartPosition ? displaced.reverse() : displaced;\n\n  var index = function () {\n    var startIndex = draggable.descriptor.index;\n    var length = ordered.length;\n\n    if (!length) {\n      return startIndex;\n    }\n\n    if (isBeyondStartPosition) {\n      return startIndex + length;\n    }\n\n    return startIndex - length;\n  }();\n\n  var movement = {\n    amount: amount,\n    displaced: ordered,\n    isBeyondStartPosition: isBeyondStartPosition\n  };\n  var impact = {\n    movement: movement,\n    direction: axis.direction,\n    destination: {\n      droppableId: home.descriptor.id,\n      index: index\n    }\n  };\n  return impact;\n};\n\nvar inForeignList = function inForeignList(_ref) {\n  var pageBorderBoxCenter = _ref.pageBorderBoxCenter,\n      draggable = _ref.draggable,\n      destination = _ref.destination,\n      insideDestination = _ref.insideDestination,\n      previousImpact = _ref.previousImpact,\n      viewport = _ref.viewport;\n  var axis = destination.axis;\n  var currentCenter = withDroppableScroll(destination, pageBorderBoxCenter);\n  var displaced = insideDestination.filter(function (child) {\n    var threshold = child.page.borderBox[axis.end];\n    return threshold > currentCenter[axis.line];\n  }).map(function (dimension) {\n    return getDisplacement({\n      draggable: dimension,\n      destination: destination,\n      previousImpact: previousImpact,\n      viewport: viewport.frame\n    });\n  });\n  var newIndex = insideDestination.length - displaced.length;\n  var movement = {\n    amount: patch(axis.line, draggable.page.marginBox[axis.size]),\n    displaced: displaced,\n    isBeyondStartPosition: false\n  };\n  var impact = {\n    movement: movement,\n    direction: axis.direction,\n    destination: {\n      droppableId: destination.descriptor.id,\n      index: newIndex\n    }\n  };\n  return impact;\n};\n\nvar getDragImpact = function getDragImpact(_ref) {\n  var pageBorderBoxCenter = _ref.pageBorderBoxCenter,\n      draggable = _ref.draggable,\n      draggables = _ref.draggables,\n      droppables = _ref.droppables,\n      previousImpact = _ref.previousImpact,\n      viewport = _ref.viewport;\n  var previousDroppableOverId = previousImpact.destination && previousImpact.destination.droppableId;\n  var destinationId = getDroppableOver({\n    target: pageBorderBoxCenter,\n    draggable: draggable,\n    draggables: draggables,\n    droppables: droppables,\n    previousDroppableOverId: previousDroppableOverId\n  });\n\n  if (!destinationId) {\n    return noImpact;\n  }\n\n  var destination = droppables[destinationId];\n\n  if (!destination.isEnabled) {\n    return noImpact;\n  }\n\n  var home = droppables[draggable.descriptor.droppableId];\n  var isWithinHomeDroppable = home.descriptor.id === destinationId;\n  var insideDestination = getDraggablesInsideDroppable(destination, draggables);\n\n  if (isWithinHomeDroppable) {\n    return inHomeList({\n      pageBorderBoxCenter: pageBorderBoxCenter,\n      draggable: draggable,\n      home: home,\n      insideHome: insideDestination,\n      previousImpact: previousImpact || noImpact,\n      viewport: viewport\n    });\n  }\n\n  return inForeignList({\n    pageBorderBoxCenter: pageBorderBoxCenter,\n    draggable: draggable,\n    destination: destination,\n    insideDestination: insideDestination,\n    previousImpact: previousImpact || noImpact,\n    viewport: viewport\n  });\n};\n\nvar getHomeLocation = function getHomeLocation(critical) {\n  return {\n    index: critical.draggable.index,\n    droppableId: critical.droppable.id\n  };\n};\n\nvar getSafeClipped = function getSafeClipped(droppable) {\n  var rect = droppable.viewport.clippedPageMarginBox;\n  !rect ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot get clipped area from droppable') : invariant(false) : void 0;\n  return rect;\n};\n\nvar getBestCrossAxisDroppable = function getBestCrossAxisDroppable(_ref) {\n  var isMovingForward = _ref.isMovingForward,\n      pageBorderBoxCenter = _ref.pageBorderBoxCenter,\n      source = _ref.source,\n      droppables = _ref.droppables,\n      viewport = _ref.viewport;\n  var sourceClipped = source.viewport.clippedPageMarginBox;\n\n  if (!sourceClipped) {\n    return null;\n  }\n\n  var axis = source.axis;\n  var isBetweenSourceClipped = isWithin(sourceClipped[axis.start], sourceClipped[axis.end]);\n  var candidates = toDroppableList(droppables).filter(function (droppable) {\n    return droppable !== source;\n  }).filter(function (droppable) {\n    return droppable.isEnabled;\n  }).filter(function (droppable) {\n    var clippedPageMarginBox = droppable.viewport.clippedPageMarginBox;\n\n    if (!clippedPageMarginBox) {\n      return false;\n    }\n\n    return isPartiallyVisibleThroughFrame(viewport.frame)(clippedPageMarginBox);\n  }).filter(function (droppable) {\n    var targetClipped = getSafeClipped(droppable);\n\n    if (isMovingForward) {\n      return sourceClipped[axis.crossAxisEnd] < targetClipped[axis.crossAxisEnd];\n    }\n\n    return targetClipped[axis.crossAxisStart] < sourceClipped[axis.crossAxisStart];\n  }).filter(function (droppable) {\n    var targetClipped = getSafeClipped(droppable);\n    var isBetweenDestinationClipped = isWithin(targetClipped[axis.start], targetClipped[axis.end]);\n    return isBetweenSourceClipped(targetClipped[axis.start]) || isBetweenSourceClipped(targetClipped[axis.end]) || isBetweenDestinationClipped(sourceClipped[axis.start]) || isBetweenDestinationClipped(sourceClipped[axis.end]);\n  }).sort(function (a, b) {\n    var first = getSafeClipped(a)[axis.crossAxisStart];\n    var second = getSafeClipped(b)[axis.crossAxisStart];\n\n    if (isMovingForward) {\n      return first - second;\n    }\n\n    return second - first;\n  }).filter(function (droppable, index, array) {\n    return getSafeClipped(droppable)[axis.crossAxisStart] === getSafeClipped(array[0])[axis.crossAxisStart];\n  });\n\n  if (!candidates.length) {\n    return null;\n  }\n\n  if (candidates.length === 1) {\n    return candidates[0];\n  }\n\n  var contains = candidates.filter(function (droppable) {\n    var isWithinDroppable = isWithin(getSafeClipped(droppable)[axis.start], getSafeClipped(droppable)[axis.end]);\n    return isWithinDroppable(pageBorderBoxCenter[axis.line]);\n  });\n\n  if (contains.length === 1) {\n    return contains[0];\n  }\n\n  if (contains.length > 1) {\n    return contains.sort(function (a, b) {\n      return getSafeClipped(a)[axis.start] - getSafeClipped(b)[axis.start];\n    })[0];\n  }\n\n  return candidates.sort(function (a, b) {\n    var first = closest(pageBorderBoxCenter, getCorners(getSafeClipped(a)));\n    var second = closest(pageBorderBoxCenter, getCorners(getSafeClipped(b)));\n\n    if (first !== second) {\n      return first - second;\n    }\n\n    return getSafeClipped(a)[axis.start] - getSafeClipped(b)[axis.start];\n  })[0];\n};\n\nvar withDroppableDisplacement = function withDroppableDisplacement(droppable, point) {\n  var closestScrollable = droppable.viewport.closestScrollable;\n\n  if (!closestScrollable) {\n    return point;\n  }\n\n  return add(point, closestScrollable.scroll.diff.displacement);\n};\n\nvar getClosestDraggable = function getClosestDraggable(_ref) {\n  var axis = _ref.axis,\n      viewport = _ref.viewport,\n      pageBorderBoxCenter = _ref.pageBorderBoxCenter,\n      destination = _ref.destination,\n      insideDestination = _ref.insideDestination;\n\n  if (!insideDestination.length) {\n    return null;\n  }\n\n  var result = insideDestination.filter(function (draggable) {\n    return isTotallyVisible({\n      target: draggable.page.borderBox,\n      destination: destination,\n      viewport: viewport.frame\n    });\n  }).sort(function (a, b) {\n    var distanceToA = distance(pageBorderBoxCenter, withDroppableDisplacement(destination, a.page.borderBox.center));\n    var distanceToB = distance(pageBorderBoxCenter, withDroppableDisplacement(destination, b.page.borderBox.center));\n\n    if (distanceToA < distanceToB) {\n      return -1;\n    }\n\n    if (distanceToB < distanceToA) {\n      return 1;\n    }\n\n    return a.page.borderBox[axis.start] - b.page.borderBox[axis.start];\n  });\n  return result.length ? result[0] : null;\n};\n\nvar moveToEdge = function moveToEdge(_ref) {\n  var source = _ref.source,\n      sourceEdge = _ref.sourceEdge,\n      destination = _ref.destination,\n      destinationEdge = _ref.destinationEdge,\n      destinationAxis = _ref.destinationAxis;\n\n  var getCorner = function getCorner(area) {\n    return patch(destinationAxis.line, area[destinationAxis[destinationEdge]], area[destinationAxis.crossAxisStart]);\n  };\n\n  var corner = getCorner(destination);\n  var centerDiff = absolute(subtract(source.center, getCorner(source)));\n  var signed = patch(destinationAxis.line, (sourceEdge === 'end' ? -1 : 1) * centerDiff[destinationAxis.line], centerDiff[destinationAxis.crossAxisLine]);\n  return add(corner, signed);\n};\n\nvar toHomeList = function toHomeList(_ref) {\n  var amount = _ref.amount,\n      homeIndex = _ref.homeIndex,\n      movingRelativeTo = _ref.movingRelativeTo,\n      insideDestination = _ref.insideDestination,\n      draggable = _ref.draggable,\n      destination = _ref.destination,\n      previousImpact = _ref.previousImpact,\n      viewport = _ref.viewport;\n  var axis = destination.axis;\n  var targetIndex = insideDestination.indexOf(movingRelativeTo);\n  !(targetIndex !== -1) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Unable to find target in destination droppable') : invariant(false) : void 0;\n\n  if (targetIndex === homeIndex) {\n    var _newCenter = draggable.page.borderBox.center;\n    var _newImpact = {\n      movement: {\n        displaced: [],\n        amount: amount,\n        isBeyondStartPosition: false\n      },\n      direction: destination.axis.direction,\n      destination: {\n        droppableId: destination.descriptor.id,\n        index: homeIndex\n      }\n    };\n    return {\n      pageBorderBoxCenter: withDroppableDisplacement(destination, _newCenter),\n      impact: _newImpact\n    };\n  }\n\n  var isMovingPastOriginalIndex = targetIndex > homeIndex;\n  var edge = isMovingPastOriginalIndex ? 'end' : 'start';\n  var newCenter = moveToEdge({\n    source: draggable.page.borderBox,\n    sourceEdge: edge,\n    destination: isMovingPastOriginalIndex ? movingRelativeTo.page.borderBox : movingRelativeTo.page.marginBox,\n    destinationEdge: edge,\n    destinationAxis: axis\n  });\n\n  var modified = function () {\n    if (!isMovingPastOriginalIndex) {\n      return insideDestination.slice(targetIndex, homeIndex);\n    }\n\n    var from = homeIndex + 1;\n    var to = targetIndex + 1;\n    return insideDestination.slice(from, to).reverse();\n  }();\n\n  var displaced = modified.map(function (dimension) {\n    return getDisplacement({\n      draggable: dimension,\n      destination: destination,\n      previousImpact: previousImpact,\n      viewport: viewport.frame\n    });\n  });\n  var newImpact = {\n    movement: {\n      displaced: displaced,\n      amount: amount,\n      isBeyondStartPosition: isMovingPastOriginalIndex\n    },\n    direction: axis.direction,\n    destination: {\n      droppableId: destination.descriptor.id,\n      index: targetIndex\n    }\n  };\n  return {\n    pageBorderBoxCenter: withDroppableDisplacement(destination, newCenter),\n    impact: newImpact\n  };\n};\n\nvar toForeignList = function toForeignList(_ref) {\n  var amount = _ref.amount,\n      pageBorderBoxCenter = _ref.pageBorderBoxCenter,\n      movingRelativeTo = _ref.movingRelativeTo,\n      insideDestination = _ref.insideDestination,\n      draggable = _ref.draggable,\n      destination = _ref.destination,\n      previousImpact = _ref.previousImpact,\n      viewport = _ref.viewport;\n  var axis = destination.axis;\n  var isGoingBeforeTarget = Boolean(movingRelativeTo && pageBorderBoxCenter[destination.axis.line] < movingRelativeTo.page.borderBox.center[destination.axis.line]);\n\n  if (!movingRelativeTo) {\n    var _newCenter = moveToEdge({\n      source: draggable.page.borderBox,\n      sourceEdge: 'start',\n      destination: destination.page.contentBox,\n      destinationEdge: 'start',\n      destinationAxis: axis\n    });\n\n    var _newImpact = {\n      movement: {\n        displaced: [],\n        amount: amount,\n        isBeyondStartPosition: false\n      },\n      direction: axis.direction,\n      destination: {\n        droppableId: destination.descriptor.id,\n        index: 0\n      }\n    };\n    return {\n      pageBorderBoxCenter: withDroppableDisplacement(destination, _newCenter),\n      impact: _newImpact\n    };\n  }\n\n  var targetIndex = insideDestination.indexOf(movingRelativeTo);\n  !(targetIndex !== -1) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'The target was not found within its droppable') : invariant(false) : void 0;\n  var proposedIndex = isGoingBeforeTarget ? targetIndex : targetIndex + 1;\n  var newCenter = moveToEdge({\n    source: draggable.page.borderBox,\n    sourceEdge: 'start',\n    destination: movingRelativeTo.page.marginBox,\n    destinationEdge: isGoingBeforeTarget ? 'start' : 'end',\n    destinationAxis: axis\n  });\n  var displaced = insideDestination.slice(proposedIndex, insideDestination.length).map(function (dimension) {\n    return getDisplacement({\n      draggable: dimension,\n      destination: destination,\n      viewport: viewport.frame,\n      previousImpact: previousImpact\n    });\n  });\n  var newImpact = {\n    movement: {\n      displaced: displaced,\n      amount: amount,\n      isBeyondStartPosition: false\n    },\n    direction: axis.direction,\n    destination: {\n      droppableId: destination.descriptor.id,\n      index: proposedIndex\n    }\n  };\n  return {\n    pageBorderBoxCenter: withDroppableDisplacement(destination, newCenter),\n    impact: newImpact\n  };\n};\n\nvar moveToNewDroppable = function moveToNewDroppable(_ref) {\n  var pageBorderBoxCenter = _ref.pageBorderBoxCenter,\n      destination = _ref.destination,\n      insideDestination = _ref.insideDestination,\n      draggable = _ref.draggable,\n      movingRelativeTo = _ref.movingRelativeTo,\n      home = _ref.home,\n      previousImpact = _ref.previousImpact,\n      viewport = _ref.viewport;\n  var amount = patch(destination.axis.line, draggable.client.marginBox[destination.axis.size]);\n\n  if (destination.descriptor.id === draggable.descriptor.droppableId) {\n    !movingRelativeTo ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'There will always be a target in the original list') : invariant(false) : void 0;\n    return toHomeList({\n      amount: amount,\n      homeIndex: home.index,\n      movingRelativeTo: movingRelativeTo,\n      insideDestination: insideDestination,\n      draggable: draggable,\n      destination: destination,\n      previousImpact: previousImpact,\n      viewport: viewport\n    });\n  }\n\n  return toForeignList({\n    amount: amount,\n    pageBorderBoxCenter: pageBorderBoxCenter,\n    movingRelativeTo: movingRelativeTo,\n    insideDestination: insideDestination,\n    draggable: draggable,\n    destination: destination,\n    previousImpact: previousImpact,\n    viewport: viewport\n  });\n};\n\nvar moveCrossAxis = function moveCrossAxis(_ref) {\n  var isMovingForward = _ref.isMovingForward,\n      pageBorderBoxCenter = _ref.pageBorderBoxCenter,\n      draggableId = _ref.draggableId,\n      droppableId = _ref.droppableId,\n      home = _ref.home,\n      draggables = _ref.draggables,\n      droppables = _ref.droppables,\n      previousImpact = _ref.previousImpact,\n      viewport = _ref.viewport;\n  var draggable = draggables[draggableId];\n  var source = droppables[droppableId];\n  var destination = getBestCrossAxisDroppable({\n    isMovingForward: isMovingForward,\n    pageBorderBoxCenter: pageBorderBoxCenter,\n    source: source,\n    droppables: droppables,\n    viewport: viewport\n  });\n\n  if (!destination) {\n    return null;\n  }\n\n  var insideDestination = getDraggablesInsideDroppable(destination, draggables);\n  var movingRelativeTo = getClosestDraggable({\n    axis: destination.axis,\n    pageBorderBoxCenter: pageBorderBoxCenter,\n    destination: destination,\n    insideDestination: insideDestination,\n    viewport: viewport\n  });\n\n  if (insideDestination.length && !movingRelativeTo) {\n    return null;\n  }\n\n  return moveToNewDroppable({\n    pageBorderBoxCenter: pageBorderBoxCenter,\n    destination: destination,\n    draggable: draggable,\n    movingRelativeTo: movingRelativeTo,\n    insideDestination: insideDestination,\n    home: home,\n    previousImpact: previousImpact || noImpact,\n    viewport: viewport\n  });\n};\n\nvar isTotallyVisibleInNewLocation = function isTotallyVisibleInNewLocation(_ref) {\n  var draggable = _ref.draggable,\n      destination = _ref.destination,\n      newPageBorderBoxCenter = _ref.newPageBorderBoxCenter,\n      viewport = _ref.viewport;\n  var diff = subtract(newPageBorderBoxCenter, draggable.page.borderBox.center);\n  var shifted = offsetByPosition(draggable.page.borderBox, diff);\n  return isTotallyVisible({\n    target: shifted,\n    destination: destination,\n    viewport: viewport\n  });\n};\n\nvar withFirstAdded = function withFirstAdded(_ref) {\n  var add = _ref.add,\n      previousImpact = _ref.previousImpact,\n      droppable = _ref.droppable,\n      draggables = _ref.draggables,\n      viewport = _ref.viewport;\n  var newDisplacement = {\n    draggableId: add,\n    isVisible: true,\n    shouldAnimate: true\n  };\n  var added = [newDisplacement].concat(previousImpact.movement.displaced);\n  var withUpdatedVisibility = added.map(function (current) {\n    if (current === newDisplacement) {\n      return current;\n    }\n\n    var updated = getDisplacement({\n      draggable: draggables[current.draggableId],\n      destination: droppable,\n      previousImpact: previousImpact,\n      viewport: viewport.frame\n    });\n    return updated;\n  });\n  return withUpdatedVisibility;\n};\n\nvar forceVisibleDisplacement = function forceVisibleDisplacement(current) {\n  if (current.isVisible) {\n    return current;\n  }\n\n  return {\n    draggableId: current.draggableId,\n    isVisible: true,\n    shouldAnimate: false\n  };\n};\n\nvar withFirstRemoved = function withFirstRemoved(_ref2) {\n  var dragging = _ref2.dragging,\n      isVisibleInNewLocation = _ref2.isVisibleInNewLocation,\n      previousImpact = _ref2.previousImpact,\n      droppable = _ref2.droppable,\n      draggables = _ref2.draggables;\n  var last = previousImpact.movement.displaced;\n  !last.length ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot remove displacement from empty list') : invariant(false) : void 0;\n  var withFirstRestored = last.slice(1, last.length);\n\n  if (!withFirstRestored.length) {\n    return withFirstRestored;\n  }\n\n  if (isVisibleInNewLocation) {\n    return withFirstRestored;\n  }\n\n  var axis = droppable.axis;\n  var sizeOfRestored = draggables[last[0].draggableId].page.marginBox[axis.size];\n  var sizeOfDragging = draggables[dragging].page.marginBox[axis.size];\n  var buffer = sizeOfRestored + sizeOfDragging;\n  var withUpdatedVisibility = withFirstRestored.map(function (displacement, index) {\n    if (index === 0) {\n      return forceVisibleDisplacement(displacement);\n    }\n\n    if (buffer > 0) {\n      var current = draggables[displacement.draggableId];\n      var size = current.page.marginBox[axis.size];\n      buffer -= size;\n      return forceVisibleDisplacement(displacement);\n    }\n\n    return {\n      draggableId: displacement.draggableId,\n      isVisible: false,\n      shouldAnimate: false\n    };\n  });\n  return withUpdatedVisibility;\n};\n\nvar inHomeList$1 = function inHomeList$1(_ref) {\n  var isMovingForward = _ref.isMovingForward,\n      draggableId = _ref.draggableId,\n      previousPageBorderBoxCenter = _ref.previousPageBorderBoxCenter,\n      previousImpact = _ref.previousImpact,\n      droppable = _ref.droppable,\n      draggables = _ref.draggables,\n      viewport = _ref.viewport;\n  var location = previousImpact.destination;\n  !location ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot move to next index in home list when there is no previous destination') : invariant(false) : void 0;\n  var draggable = draggables[draggableId];\n  var axis = droppable.axis;\n  var insideDroppable = getDraggablesInsideDroppable(droppable, draggables);\n  var startIndex = draggable.descriptor.index;\n  var currentIndex = location.index;\n  var proposedIndex = isMovingForward ? currentIndex + 1 : currentIndex - 1;\n\n  if (proposedIndex > insideDroppable.length - 1) {\n    return null;\n  }\n\n  if (proposedIndex < 0) {\n    return null;\n  }\n\n  var destination = insideDroppable[proposedIndex];\n  var isMovingTowardStart = isMovingForward && proposedIndex <= startIndex || !isMovingForward && proposedIndex >= startIndex;\n\n  var edge = function () {\n    if (!isMovingTowardStart) {\n      return isMovingForward ? 'end' : 'start';\n    }\n\n    return isMovingForward ? 'start' : 'end';\n  }();\n\n  var newPageBorderBoxCenter = moveToEdge({\n    source: draggable.page.borderBox,\n    sourceEdge: edge,\n    destination: destination.page.borderBox,\n    destinationEdge: edge,\n    destinationAxis: droppable.axis\n  });\n  var isVisibleInNewLocation = isTotallyVisibleInNewLocation({\n    draggable: draggable,\n    destination: droppable,\n    newPageBorderBoxCenter: newPageBorderBoxCenter,\n    viewport: viewport.frame\n  });\n  var displaced = isMovingTowardStart ? withFirstRemoved({\n    dragging: draggableId,\n    isVisibleInNewLocation: isVisibleInNewLocation,\n    previousImpact: previousImpact,\n    droppable: droppable,\n    draggables: draggables\n  }) : withFirstAdded({\n    add: destination.descriptor.id,\n    previousImpact: previousImpact,\n    droppable: droppable,\n    draggables: draggables,\n    viewport: viewport\n  });\n  var newImpact = {\n    movement: {\n      displaced: displaced,\n      amount: patch(axis.line, draggable.page.marginBox[axis.size]),\n      isBeyondStartPosition: proposedIndex > startIndex\n    },\n    destination: {\n      droppableId: droppable.descriptor.id,\n      index: proposedIndex\n    },\n    direction: droppable.axis.direction\n  };\n\n  if (isVisibleInNewLocation) {\n    return {\n      pageBorderBoxCenter: withDroppableDisplacement(droppable, newPageBorderBoxCenter),\n      impact: newImpact,\n      scrollJumpRequest: null\n    };\n  }\n\n  var distance$$1 = subtract(newPageBorderBoxCenter, previousPageBorderBoxCenter);\n  var distanceWithScroll = withDroppableDisplacement(droppable, distance$$1);\n  return {\n    pageBorderBoxCenter: previousPageBorderBoxCenter,\n    impact: newImpact,\n    scrollJumpRequest: distanceWithScroll\n  };\n};\n\nvar inForeignList$1 = function inForeignList$1(_ref) {\n  var isMovingForward = _ref.isMovingForward,\n      draggableId = _ref.draggableId,\n      previousImpact = _ref.previousImpact,\n      previousPageBorderBoxCenter = _ref.previousPageBorderBoxCenter,\n      droppable = _ref.droppable,\n      draggables = _ref.draggables,\n      viewport = _ref.viewport;\n  !previousImpact.destination ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot move to next index where there is no previous destination') : invariant(false) : void 0;\n  var location = previousImpact.destination;\n  var draggable = draggables[draggableId];\n  var axis = droppable.axis;\n  var insideForeignDroppable = getDraggablesInsideDroppable(droppable, draggables);\n  var currentIndex = location.index;\n  var proposedIndex = isMovingForward ? currentIndex + 1 : currentIndex - 1;\n  var lastIndex = insideForeignDroppable.length - 1;\n\n  if (proposedIndex > insideForeignDroppable.length) {\n    return null;\n  }\n\n  if (proposedIndex < 0) {\n    return null;\n  }\n\n  var movingRelativeTo = insideForeignDroppable[Math.min(proposedIndex, lastIndex)];\n  var isMovingPastLastIndex = proposedIndex > lastIndex;\n  var sourceEdge = 'start';\n\n  var destinationEdge = function () {\n    if (isMovingPastLastIndex) {\n      return 'end';\n    }\n\n    return 'start';\n  }();\n\n  var newPageBorderBoxCenter = moveToEdge({\n    source: draggable.page.borderBox,\n    sourceEdge: sourceEdge,\n    destination: movingRelativeTo.page.marginBox,\n    destinationEdge: destinationEdge,\n    destinationAxis: droppable.axis\n  });\n  var isVisibleInNewLocation = isTotallyVisibleInNewLocation({\n    draggable: draggable,\n    destination: droppable,\n    newPageBorderBoxCenter: newPageBorderBoxCenter,\n    viewport: viewport.frame\n  });\n\n  var displaced = function () {\n    if (isMovingForward) {\n      return withFirstRemoved({\n        dragging: draggableId,\n        isVisibleInNewLocation: isVisibleInNewLocation,\n        previousImpact: previousImpact,\n        droppable: droppable,\n        draggables: draggables\n      });\n    }\n\n    return withFirstAdded({\n      add: movingRelativeTo.descriptor.id,\n      previousImpact: previousImpact,\n      droppable: droppable,\n      draggables: draggables,\n      viewport: viewport\n    });\n  }();\n\n  var newImpact = {\n    movement: {\n      displaced: displaced,\n      amount: patch(axis.line, draggable.page.marginBox[axis.size]),\n      isBeyondStartPosition: false\n    },\n    destination: {\n      droppableId: droppable.descriptor.id,\n      index: proposedIndex\n    },\n    direction: droppable.axis.direction\n  };\n\n  if (isVisibleInNewLocation) {\n    return {\n      pageBorderBoxCenter: withDroppableDisplacement(droppable, newPageBorderBoxCenter),\n      impact: newImpact,\n      scrollJumpRequest: null\n    };\n  }\n\n  var distanceMoving = subtract(newPageBorderBoxCenter, previousPageBorderBoxCenter);\n  var distanceWithScroll = withDroppableDisplacement(droppable, distanceMoving);\n  return {\n    pageBorderBoxCenter: previousPageBorderBoxCenter,\n    impact: newImpact,\n    scrollJumpRequest: distanceWithScroll\n  };\n};\n\nvar moveToNextIndex = function moveToNextIndex(args) {\n  var draggableId = args.draggableId,\n      draggables = args.draggables,\n      droppable = args.droppable;\n  var draggable = draggables[draggableId];\n  var isInHomeList = draggable.descriptor.droppableId === droppable.descriptor.id;\n\n  if (!droppable.isEnabled) {\n    return null;\n  }\n\n  if (isInHomeList) {\n    return inHomeList$1(args);\n  }\n\n  return inForeignList$1(args);\n};\n\nvar getClientSelection = function getClientSelection(pageBorderBoxCenter, currentScroll) {\n  return subtract(pageBorderBoxCenter, currentScroll);\n};\n\nvar moveInDirection = function moveInDirection(_ref) {\n  var state = _ref.state,\n      type = _ref.type;\n\n  var _ref2 = function () {\n    if (state.impact.destination) {\n      return {\n        droppable: state.dimensions.droppables[state.impact.destination.droppableId],\n        isMainAxisMovementAllowed: true\n      };\n    }\n\n    return {\n      droppable: state.dimensions.droppables[state.critical.droppable.id],\n      isMainAxisMovementAllowed: false\n    };\n  }(),\n      droppable = _ref2.droppable,\n      isMainAxisMovementAllowed = _ref2.isMainAxisMovementAllowed;\n\n  var direction = droppable.axis.direction;\n  var isMovingOnMainAxis = direction === 'vertical' && (type === 'MOVE_UP' || type === 'MOVE_DOWN') || direction === 'horizontal' && (type === 'MOVE_LEFT' || type === 'MOVE_RIGHT');\n\n  if (isMovingOnMainAxis && !isMainAxisMovementAllowed) {\n    return null;\n  }\n\n  var isMovingForward = type === 'MOVE_DOWN' || type === 'MOVE_RIGHT';\n\n  if (isMovingOnMainAxis) {\n    var _result = moveToNextIndex({\n      isMovingForward: isMovingForward,\n      draggableId: state.critical.draggable.id,\n      droppable: droppable,\n      draggables: state.dimensions.draggables,\n      previousPageBorderBoxCenter: state.current.page.borderBoxCenter,\n      previousImpact: state.impact,\n      viewport: state.viewport\n    });\n\n    if (!_result) {\n      return null;\n    }\n\n    return {\n      impact: _result.impact,\n      clientSelection: getClientSelection(_result.pageBorderBoxCenter, state.viewport.scroll.current),\n      scrollJumpRequest: _result.scrollJumpRequest\n    };\n  }\n\n  var home = getHomeLocation(state.critical);\n  var result = moveCrossAxis({\n    isMovingForward: isMovingForward,\n    pageBorderBoxCenter: state.current.page.borderBoxCenter,\n    draggableId: state.critical.draggable.id,\n    droppableId: droppable.descriptor.id,\n    home: home,\n    draggables: state.dimensions.draggables,\n    droppables: state.dimensions.droppables,\n    previousImpact: state.impact,\n    viewport: state.viewport\n  });\n\n  if (!result) {\n    return null;\n  }\n\n  return {\n    clientSelection: getClientSelection(result.pageBorderBoxCenter, state.viewport.scroll.current),\n    impact: result.impact,\n    scrollJumpRequest: null\n  };\n};\n\nvar scrollViewport = function scrollViewport(viewport, newScroll) {\n  var diff = subtract(newScroll, viewport.scroll.initial);\n  var displacement = negate(diff);\n  var frame = getRect({\n    top: newScroll.y,\n    bottom: newScroll.y + viewport.frame.height,\n    left: newScroll.x,\n    right: newScroll.x + viewport.frame.width\n  });\n  var updated = {\n    frame: frame,\n    scroll: {\n      initial: viewport.scroll.initial,\n      max: viewport.scroll.max,\n      current: newScroll,\n      diff: {\n        value: diff,\n        displacement: displacement\n      }\n    }\n  };\n  return updated;\n};\n\nvar getHomeImpact = function getHomeImpact(critical, dimensions) {\n  var home = dimensions.droppables[critical.droppable.id];\n  var axis = home.axis;\n  var draggable = dimensions.draggables[critical.draggable.id];\n  return {\n    movement: {\n      displaced: [],\n      isBeyondStartPosition: false,\n      amount: patch(axis.line, draggable.client.marginBox[axis.size])\n    },\n    direction: axis.direction,\n    destination: getHomeLocation(critical)\n  };\n};\n\nvar getPageItemPositions = function getPageItemPositions(client, windowScroll) {\n  return {\n    selection: add(client.selection, windowScroll),\n    borderBoxCenter: add(client.borderBoxCenter, windowScroll),\n    offset: add(client.offset, windowScroll)\n  };\n};\n\nfunction isMovementAllowed(state) {\n  return state.phase === 'DRAGGING' || state.phase === 'COLLECTING';\n}\n\nvar idle = {\n  phase: 'IDLE'\n};\nvar preparing = {\n  phase: 'PREPARING'\n};\n\nvar moveWithPositionUpdates = function moveWithPositionUpdates(_ref) {\n  var state = _ref.state,\n      clientSelection = _ref.clientSelection,\n      shouldAnimate = _ref.shouldAnimate,\n      viewport = _ref.viewport,\n      impact = _ref.impact,\n      scrollJumpRequest = _ref.scrollJumpRequest;\n  var newViewport = viewport || state.viewport;\n  var currentWindowScroll = newViewport.scroll.current;\n\n  var client = function () {\n    var offset = subtract(clientSelection, state.initial.client.selection);\n    return {\n      offset: offset,\n      selection: clientSelection,\n      borderBoxCenter: add(state.initial.client.borderBoxCenter, offset)\n    };\n  }();\n\n  var page = getPageItemPositions(client, currentWindowScroll);\n  var current = {\n    client: client,\n    page: page\n  };\n\n  if (state.phase === 'COLLECTING') {\n    return _extends({\n      phase: 'COLLECTING'\n    }, state, {\n      current: current\n    });\n  }\n\n  var newImpact = impact || getDragImpact({\n    pageBorderBoxCenter: page.borderBoxCenter,\n    draggable: state.dimensions.draggables[state.critical.draggable.id],\n    draggables: state.dimensions.draggables,\n    droppables: state.dimensions.droppables,\n    previousImpact: state.impact,\n    viewport: newViewport\n  });\n\n  var result = _extends({}, state, {\n    current: current,\n    shouldAnimate: shouldAnimate,\n    impact: newImpact,\n    scrollJumpRequest: scrollJumpRequest || null,\n    viewport: newViewport\n  });\n\n  return result;\n};\n\nvar reducer = function reducer(state, action) {\n  if (state === void 0) {\n    state = idle;\n  }\n\n  if (action.type === 'CLEAN') {\n    return idle;\n  }\n\n  if (action.type === 'PREPARE') {\n    return preparing;\n  }\n\n  if (action.type === 'INITIAL_PUBLISH') {\n    !(state.phase === 'PREPARING') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'INITIAL_PUBLISH must come after a PREPARING phase') : invariant(false) : void 0;\n    var _action$payload = action.payload,\n        critical = _action$payload.critical,\n        client = _action$payload.client,\n        viewport = _action$payload.viewport,\n        dimensions = _action$payload.dimensions,\n        autoScrollMode = _action$payload.autoScrollMode;\n    var initial = {\n      client: client,\n      page: {\n        selection: add(client.selection, viewport.scroll.initial),\n        borderBoxCenter: add(client.selection, viewport.scroll.initial),\n        offset: origin\n      }\n    };\n    var result = {\n      phase: 'DRAGGING',\n      isDragging: true,\n      critical: critical,\n      autoScrollMode: autoScrollMode,\n      dimensions: dimensions,\n      initial: initial,\n      current: initial,\n      impact: getHomeImpact(critical, dimensions),\n      viewport: viewport,\n      scrollJumpRequest: null,\n      shouldAnimate: false\n    };\n    return result;\n  }\n\n  if (action.type === 'COLLECTION_STARTING') {\n    var _extends2;\n\n    if (state.phase === 'COLLECTING' || state.phase === 'DROP_PENDING') {\n      return state;\n    }\n\n    !(state.phase === 'DRAGGING') ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Collection cannot start from phase \" + state.phase) : invariant(false) : void 0;\n\n    var _result = _extends({\n      phase: 'COLLECTING'\n    }, state, (_extends2 = {}, _extends2[\"phase\"] = 'COLLECTING', _extends2));\n\n    return _result;\n  }\n\n  if (action.type === 'PUBLISH') {\n    !(state.phase === 'COLLECTING' || state.phase === 'DROP_PENDING') ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Unexpected \" + action.type + \" received in phase \" + state.phase) : invariant(false) : void 0;\n    process.env.NODE_ENV !== \"production\" ? invariant(false, \"Dynamic additions and removals of Draggable and Droppable components\\n      is currently not supported. But will be soon!\") : invariant(false);\n  }\n\n  if (action.type === 'MOVE') {\n    if (state.phase === 'PREPARING') {\n      return state;\n    }\n\n    if (state.phase === 'DROP_PENDING') {\n      return state;\n    }\n\n    !isMovementAllowed(state) ? process.env.NODE_ENV !== \"production\" ? invariant(false, action.type + \" not permitted in phase \" + state.phase) : invariant(false) : void 0;\n    var _action$payload2 = action.payload,\n        _client = _action$payload2.client,\n        shouldAnimate = _action$payload2.shouldAnimate;\n\n    if (state.shouldAnimate === shouldAnimate && isEqual(_client, state.current.client.selection)) {\n      return state;\n    }\n\n    var impact = state.autoScrollMode === 'JUMP' ? state.impact : null;\n    return moveWithPositionUpdates({\n      state: state,\n      clientSelection: _client,\n      impact: impact,\n      shouldAnimate: shouldAnimate\n    });\n  }\n\n  if (action.type === 'UPDATE_DROPPABLE_SCROLL') {\n    var _extends3, _extends4;\n\n    if (state.phase === 'PREPARING') {\n      return state;\n    }\n\n    if (state.phase === 'DROP_PENDING') {\n      return state;\n    }\n\n    !isMovementAllowed(state) ? process.env.NODE_ENV !== \"production\" ? invariant(false, action.type + \" not permitted in phase \" + state.phase) : invariant(false) : void 0;\n    var _action$payload3 = action.payload,\n        id = _action$payload3.id,\n        offset = _action$payload3.offset;\n    var target = state.dimensions.droppables[id];\n\n    if (!target) {\n      return state;\n    }\n\n    var updated = scrollDroppable(target, offset);\n\n    var _dimensions = _extends({}, state.dimensions, {\n      droppables: _extends({}, state.dimensions.droppables, (_extends3 = {}, _extends3[id] = updated, _extends3))\n    });\n\n    var _impact = function () {\n      !isMovementAllowed(state) ? process.env.NODE_ENV !== \"production\" ? invariant(false) : invariant(false) : void 0;\n\n      if (state.autoScrollMode === 'JUMP') {\n        return state.impact;\n      }\n\n      return getDragImpact({\n        pageBorderBoxCenter: state.current.page.borderBoxCenter,\n        draggable: _dimensions.draggables[state.critical.draggable.id],\n        draggables: _dimensions.draggables,\n        droppables: _dimensions.droppables,\n        previousImpact: state.impact,\n        viewport: state.viewport\n      });\n    }();\n\n    return _extends({\n      phase: 'DRAGGING'\n    }, state, (_extends4 = {}, _extends4[\"phase\"] = state.phase, _extends4.impact = _impact, _extends4.dimensions = _dimensions, _extends4.scrollJumpRequest = null, _extends4));\n  }\n\n  if (action.type === 'UPDATE_DROPPABLE_IS_ENABLED') {\n    var _extends5, _extends6;\n\n    if (state.phase === 'DROP_PENDING') {\n      return state;\n    }\n\n    !isMovementAllowed(state) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Attempting to move in an unsupported phase \" + state.phase) : invariant(false) : void 0;\n    var _action$payload4 = action.payload,\n        _id = _action$payload4.id,\n        isEnabled = _action$payload4.isEnabled;\n    var _target = state.dimensions.droppables[_id];\n    !_target ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Cannot find Droppable[id: \" + _id + \"] to toggle its enabled state\") : invariant(false) : void 0;\n    !(_target.isEnabled !== isEnabled) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Trying to set droppable isEnabled to \" + String(isEnabled) + \"\\n      but it is already \" + String(_target.isEnabled)) : invariant(false) : void 0;\n\n    var _updated = _extends({}, _target, {\n      isEnabled: isEnabled\n    });\n\n    var _dimensions2 = _extends({}, state.dimensions, {\n      droppables: _extends({}, state.dimensions.droppables, (_extends5 = {}, _extends5[_id] = _updated, _extends5))\n    });\n\n    var _impact2 = getDragImpact({\n      pageBorderBoxCenter: state.current.page.borderBoxCenter,\n      draggable: _dimensions2.draggables[state.critical.draggable.id],\n      draggables: _dimensions2.draggables,\n      droppables: _dimensions2.droppables,\n      previousImpact: state.impact,\n      viewport: state.viewport\n    });\n\n    return _extends({\n      phase: 'DRAGGING'\n    }, state, (_extends6 = {}, _extends6[\"phase\"] = state.phase, _extends6.impact = _impact2, _extends6.dimensions = _dimensions2, _extends6));\n  }\n\n  if (action.type === 'MOVE_BY_WINDOW_SCROLL') {\n    if (state.phase === 'PREPARING') {\n      return state;\n    }\n\n    if (state.phase === 'DROP_PENDING' || state.phase === 'DROP_ANIMATING') {\n      return state;\n    }\n\n    !isMovementAllowed(state) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Cannot move by window in phase \" + state.phase) : invariant(false) : void 0;\n    var newScroll = action.payload.scroll;\n\n    if (isEqual(state.viewport.scroll.current, newScroll)) {\n      return state;\n    }\n\n    var isJumpScrolling = state.autoScrollMode === 'JUMP';\n\n    var _impact3 = isJumpScrolling ? state.impact : null;\n\n    var _viewport = scrollViewport(state.viewport, newScroll);\n\n    return moveWithPositionUpdates({\n      state: state,\n      clientSelection: state.current.client.selection,\n      viewport: _viewport,\n      shouldAnimate: false,\n      impact: _impact3\n    });\n  }\n\n  if (action.type === 'UPDATE_VIEWPORT_MAX_SCROLL') {\n    var _extends7;\n\n    !state.isDragging ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot update the max viewport scroll if not dragging') : invariant(false) : void 0;\n    var existing = state.viewport;\n\n    var _viewport2 = _extends({}, existing, {\n      scroll: _extends({}, existing.scroll, {\n        max: action.payload\n      })\n    });\n\n    return _extends({\n      phase: 'DRAGGING'\n    }, state, (_extends7 = {}, _extends7[\"phase\"] = state.phase, _extends7.viewport = _viewport2, _extends7));\n  }\n\n  if (action.type === 'MOVE_UP' || action.type === 'MOVE_DOWN' || action.type === 'MOVE_LEFT' || action.type === 'MOVE_RIGHT') {\n    if (state.phase === 'PREPARING') {\n      return state;\n    }\n\n    if (state.phase === 'COLLECTING' || state.phase === 'DROP_PENDING') {\n      return state;\n    }\n\n    !(state.phase === 'DRAGGING') ? process.env.NODE_ENV !== \"production\" ? invariant(false, action.type + \" received while not in DRAGGING phase\") : invariant(false) : void 0;\n\n    var _result2 = moveInDirection({\n      state: state,\n      type: action.type\n    });\n\n    if (!_result2) {\n      return state;\n    }\n\n    return moveWithPositionUpdates({\n      state: state,\n      impact: _result2.impact,\n      clientSelection: _result2.clientSelection,\n      shouldAnimate: true,\n      scrollJumpRequest: _result2.scrollJumpRequest\n    });\n  }\n\n  if (action.type === 'DROP_PENDING') {\n    var _extends8;\n\n    var reason = action.payload.reason;\n    !(state.phase === 'COLLECTING') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Can only move into the DROP_PENDING phase from the COLLECTING phase') : invariant(false) : void 0;\n\n    var newState = _extends({\n      phase: 'DROP_PENDING'\n    }, state, (_extends8 = {}, _extends8[\"phase\"] = 'DROP_PENDING', _extends8.isWaiting = true, _extends8.reason = reason, _extends8));\n\n    return newState;\n  }\n\n  if (action.type === 'DROP_ANIMATE') {\n    var pending = action.payload;\n    !(state.phase === 'DRAGGING' || state.phase === 'DROP_PENDING') ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Cannot animate drop from phase \" + state.phase) : invariant(false) : void 0;\n    var _result3 = {\n      phase: 'DROP_ANIMATING',\n      pending: pending,\n      dimensions: state.dimensions\n    };\n    return _result3;\n  }\n\n  if (action.type === 'DROP_COMPLETE') {\n    return idle;\n  }\n\n  return state;\n};\n\nvar lift = function lift(args) {\n  return {\n    type: 'LIFT',\n    payload: args\n  };\n};\n\nvar initialPublish = function initialPublish(args) {\n  return {\n    type: 'INITIAL_PUBLISH',\n    payload: args\n  };\n};\n\nvar publish = function publish(args) {\n  return {\n    type: 'PUBLISH',\n    payload: args\n  };\n};\n\nvar collectionStarting = function collectionStarting() {\n  return {\n    type: 'COLLECTION_STARTING',\n    payload: null\n  };\n};\n\nvar updateDroppableScroll = function updateDroppableScroll(args) {\n  return {\n    type: 'UPDATE_DROPPABLE_SCROLL',\n    payload: args\n  };\n};\n\nvar updateDroppableIsEnabled = function updateDroppableIsEnabled(args) {\n  return {\n    type: 'UPDATE_DROPPABLE_IS_ENABLED',\n    payload: args\n  };\n};\n\nvar move = function move(args) {\n  return {\n    type: 'MOVE',\n    payload: args\n  };\n};\n\nvar moveByWindowScroll = function moveByWindowScroll(args) {\n  return {\n    type: 'MOVE_BY_WINDOW_SCROLL',\n    payload: args\n  };\n};\n\nvar updateViewportMaxScroll = function updateViewportMaxScroll(max) {\n  return {\n    type: 'UPDATE_VIEWPORT_MAX_SCROLL',\n    payload: max\n  };\n};\n\nvar moveUp = function moveUp() {\n  return {\n    type: 'MOVE_UP',\n    payload: null\n  };\n};\n\nvar moveDown = function moveDown() {\n  return {\n    type: 'MOVE_DOWN',\n    payload: null\n  };\n};\n\nvar moveRight = function moveRight() {\n  return {\n    type: 'MOVE_RIGHT',\n    payload: null\n  };\n};\n\nvar moveLeft = function moveLeft() {\n  return {\n    type: 'MOVE_LEFT',\n    payload: null\n  };\n};\n\nvar clean = function clean() {\n  return {\n    type: 'CLEAN',\n    payload: null\n  };\n};\n\nvar prepare = function prepare() {\n  return {\n    type: 'PREPARE',\n    payload: null\n  };\n};\n\nvar animateDrop = function animateDrop(pending) {\n  return {\n    type: 'DROP_ANIMATE',\n    payload: pending\n  };\n};\n\nvar completeDrop = function completeDrop(result) {\n  return {\n    type: 'DROP_COMPLETE',\n    payload: result\n  };\n};\n\nvar drop = function drop(args) {\n  return {\n    type: 'DROP',\n    payload: args\n  };\n};\n\nvar dropPending = function dropPending(args) {\n  return {\n    type: 'DROP_PENDING',\n    payload: args\n  };\n};\n\nvar dropAnimationFinished = function dropAnimationFinished() {\n  return {\n    type: 'DROP_ANIMATION_FINISHED',\n    payload: null\n  };\n};\n\nvar lift$1 = function lift$1(getMarshal) {\n  var timeoutId = null;\n\n  var tryAbortCriticalCollection = function tryAbortCriticalCollection() {\n    if (timeoutId == null) {\n      return;\n    }\n\n    clearTimeout(timeoutId);\n    timeoutId = null;\n  };\n\n  return function (_ref) {\n    var getState = _ref.getState,\n        dispatch = _ref.dispatch;\n    return function (next) {\n      return function (action) {\n        if (action.type === 'CLEAN') {\n          tryAbortCriticalCollection();\n          next(action);\n          return;\n        }\n\n        if (action.type !== 'LIFT') {\n          next(action);\n          return;\n        }\n\n        !!timeoutId ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'There should not be a pending complete lift phase when a lift action is fired') : invariant(false) : void 0;\n        var marshal = getMarshal();\n        var _action$payload = action.payload,\n            id = _action$payload.id,\n            client = _action$payload.client,\n            autoScrollMode = _action$payload.autoScrollMode,\n            viewport = _action$payload.viewport;\n        var initial = getState();\n\n        if (initial.phase === 'DROP_ANIMATING') {\n          dispatch(completeDrop(initial.pending.result));\n        }\n\n        var postFlushState = getState();\n        !(postFlushState.phase === 'IDLE') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Incorrect phase to start a drag') : invariant(false) : void 0;\n        dispatch(prepare());\n        timeoutId = setTimeout(function () {\n          timeoutId = null;\n          var state = getState();\n          !(state.phase === 'PREPARING') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Invalid phase for completing lift') : invariant(false) : void 0;\n          var scrollOptions = {\n            shouldPublishImmediately: autoScrollMode === 'JUMP'\n          };\n          var request = {\n            draggableId: id,\n            scrollOptions: scrollOptions\n          };\n\n          var _marshal$startPublish = marshal.startPublishing(request, viewport.scroll.current),\n              critical = _marshal$startPublish.critical,\n              dimensions = _marshal$startPublish.dimensions;\n\n          dispatch(initialPublish({\n            critical: critical,\n            dimensions: dimensions,\n            client: client,\n            autoScrollMode: autoScrollMode,\n            viewport: viewport\n          }));\n        });\n      };\n    };\n  };\n};\n\nvar style = function style(marshal) {\n  return function () {\n    return function (next) {\n      return function (action) {\n        if (action.type === 'INITIAL_PUBLISH') {\n          marshal.dragging();\n        }\n\n        if (action.type === 'COLLECTION_STARTING') {\n          marshal.collecting();\n        }\n\n        if (action.type === 'PUBLISH') {\n          marshal.dragging();\n        }\n\n        if (action.type === 'DROP_ANIMATE') {\n          marshal.dropping(action.payload.result.reason);\n        }\n\n        if (action.type === 'CLEAN' || action.type === 'DROP_COMPLETE') {\n          marshal.resting();\n        }\n\n        next(action);\n      };\n    };\n  };\n};\n\nvar getNewHomeClientBorderBoxCenter = function getNewHomeClientBorderBoxCenter(_ref) {\n  var movement = _ref.movement,\n      draggable = _ref.draggable,\n      draggables = _ref.draggables,\n      destination = _ref.destination;\n  var originalCenter = draggable.client.borderBox.center;\n\n  if (destination == null) {\n    return originalCenter;\n  }\n\n  var displaced = movement.displaced,\n      isBeyondStartPosition = movement.isBeyondStartPosition;\n  var axis = destination.axis;\n  var isWithinHomeDroppable = destination.descriptor.id === draggable.descriptor.droppableId;\n\n  if (isWithinHomeDroppable && !displaced.length) {\n    return originalCenter;\n  }\n\n  var draggablesInDestination = getDraggablesInsideDroppable(destination, draggables);\n\n  var movingRelativeTo = function () {\n    if (isWithinHomeDroppable) {\n      return draggables[displaced[0].draggableId].client.borderBox;\n    }\n\n    if (displaced.length) {\n      return draggables[displaced[0].draggableId].client.borderBox;\n    }\n\n    if (draggablesInDestination.length) {\n      return draggablesInDestination[draggablesInDestination.length - 1].client.marginBox;\n    }\n\n    return destination.client.contentBox;\n  }();\n\n  var _ref2 = function () {\n    if (isWithinHomeDroppable) {\n      if (isBeyondStartPosition) {\n        return {\n          sourceEdge: 'end',\n          destinationEdge: 'end'\n        };\n      }\n\n      return {\n        sourceEdge: 'start',\n        destinationEdge: 'start'\n      };\n    }\n\n    if (!displaced.length && draggablesInDestination.length) {\n      return {\n        sourceEdge: 'start',\n        destinationEdge: 'end'\n      };\n    }\n\n    return {\n      sourceEdge: 'start',\n      destinationEdge: 'start'\n    };\n  }(),\n      sourceEdge = _ref2.sourceEdge,\n      destinationEdge = _ref2.destinationEdge;\n\n  var source = draggable.client.borderBox;\n  var targetCenter = moveToEdge({\n    source: source,\n    sourceEdge: sourceEdge,\n    destination: movingRelativeTo,\n    destinationEdge: destinationEdge,\n    destinationAxis: axis\n  });\n  return targetCenter;\n};\n\nvar getScrollDisplacement = function getScrollDisplacement(droppable, viewport) {\n  return withDroppableDisplacement(droppable, viewport.scroll.diff.displacement);\n};\n\nvar drop$1 = function drop$1(_ref) {\n  var getState = _ref.getState,\n      dispatch = _ref.dispatch;\n  return function (next) {\n    return function (action) {\n      if (action.type !== 'DROP') {\n        next(action);\n        return;\n      }\n\n      var state = getState();\n      var reason = action.payload.reason;\n\n      if (state.phase === 'COLLECTING') {\n        dispatch(dropPending({\n          reason: reason\n        }));\n        return;\n      }\n\n      if (state.phase === 'PREPARING') {\n        dispatch(clean());\n        return;\n      }\n\n      if (state.phase === 'IDLE') {\n        return;\n      }\n\n      var isWaitingForDrop = state.phase === 'DROP_PENDING' && state.isWaiting;\n      !!isWaitingForDrop ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'A DROP action occurred while DROP_PENDING and still waiting') : invariant(false) : void 0;\n      !(state.phase === 'DRAGGING' || state.phase === 'DROP_PENDING') ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Cannot drop in phase: \" + state.phase) : invariant(false) : void 0;\n      var critical = state.critical;\n      var dimensions = state.dimensions;\n      var impact = reason === 'DROP' ? state.impact : noImpact;\n      var home = dimensions.droppables[state.critical.droppable.id];\n      var draggable = dimensions.draggables[state.critical.draggable.id];\n      var droppable = impact && impact.destination ? dimensions.droppables[impact.destination.droppableId] : null;\n      var source = {\n        index: critical.draggable.index,\n        droppableId: critical.droppable.id\n      };\n      var destination = reason === 'DROP' ? impact.destination : null;\n      var result = {\n        draggableId: draggable.descriptor.id,\n        type: home.descriptor.type,\n        source: source,\n        destination: destination,\n        reason: reason\n      };\n\n      var clientOffset = function () {\n        if (reason === 'CANCEL') {\n          return origin;\n        }\n\n        var newBorderBoxClientCenter = getNewHomeClientBorderBoxCenter({\n          movement: impact.movement,\n          draggable: draggable,\n          draggables: dimensions.draggables,\n          destination: droppable\n        });\n        return subtract(newBorderBoxClientCenter, draggable.client.borderBox.center);\n      }();\n\n      var newHomeOffset = add(clientOffset, getScrollDisplacement(droppable || home, state.viewport));\n      var isAnimationRequired = !isEqual(state.current.client.offset, newHomeOffset);\n      var pending = {\n        newHomeOffset: newHomeOffset,\n        result: result,\n        impact: impact\n      };\n\n      if (isAnimationRequired) {\n        dispatch(animateDrop(pending));\n        return;\n      }\n\n      dispatch(completeDrop(result));\n    };\n  };\n};\n\nvar onDragStart = function onDragStart(start) {\n  return \"\\n  You have lifted an item in position \" + (start.source.index + 1) + \".\\n  Use the arrow keys to move, space bar to drop, and escape to cancel.\\n\";\n};\n\nvar onDragUpdate = function onDragUpdate(update) {\n  if (!update.destination) {\n    return 'You are currently not dragging over a droppable area';\n  }\n\n  if (update.source.droppableId === update.destination.droppableId) {\n    return \"You have moved the item to position \" + (update.destination.index + 1);\n  }\n\n  return \"\\n    You have moved the item from list \" + update.source.droppableId + \" in position \" + (update.source.index + 1) + \"\\n    to list \" + update.destination.droppableId + \" in position \" + (update.destination.index + 1) + \"\\n  \";\n};\n\nvar onDragEnd = function onDragEnd(result) {\n  if (result.reason === 'CANCEL') {\n    return \"\\n      Movement cancelled.\\n      The item has returned to its starting position of \" + (result.source.index + 1) + \"\\n    \";\n  }\n\n  if (!result.destination) {\n    return \"\\n      The item has been dropped while not over a droppable location.\\n      The item has returned to its starting position of \" + (result.source.index + 1) + \"\\n    \";\n  }\n\n  if (result.source.droppableId === result.destination.droppableId) {\n    if (result.source.index === result.destination.index) {\n      return \"\\n        You have dropped the item.\\n        It has been dropped on its starting position of \" + (result.source.index + 1) + \"\\n      \";\n    }\n\n    return \"\\n      You have dropped the item.\\n      It has moved from position \" + (result.source.index + 1) + \" to \" + (result.destination.index + 1) + \"\\n    \";\n  }\n\n  return \"\\n    You have dropped the item.\\n    It has moved from position \" + (result.source.index + 1) + \" in list \" + result.source.droppableId + \"\\n    to position \" + (result.destination.index + 1) + \" in list \" + result.destination.droppableId + \"\\n  \";\n};\n\nvar preset = {\n  onDragStart: onDragStart,\n  onDragUpdate: onDragUpdate,\n  onDragEnd: onDragEnd\n};\nvar records = {};\nvar flag = '__react-beautiful-dnd-debug-timings-hook__';\n\nvar isTimingsEnabled = function isTimingsEnabled() {\n  return Boolean(window[flag]);\n};\n\nvar start = function start(key) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (!isTimingsEnabled()) {\n      return;\n    }\n\n    var now = performance.now();\n    records[key] = now;\n  }\n};\n\nvar finish = function finish(key) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (!isTimingsEnabled()) {\n      return;\n    }\n\n    var now = performance.now();\n    var previous = records[key];\n    !previous ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'cannot finish timing as no previous time found') : invariant(false) : void 0;\n    var result = now - previous;\n    var rounded = result.toFixed(2);\n\n    var style = function () {\n      if (result < 12) {\n        return {\n          textColor: 'green',\n          symbol: '✅'\n        };\n      }\n\n      if (result < 40) {\n        return {\n          textColor: 'orange',\n          symbol: '⚠️'\n        };\n      }\n\n      return {\n        textColor: 'red',\n        symbol: '❌'\n      };\n    }();\n\n    console.log(style.symbol + \" %cTiming %c\" + rounded + \" %cms %c\" + key, 'color: blue; font-weight: bold; ', \"color: \" + style.textColor + \"; font-size: 1.1em;\", 'color: grey;', 'color: purple; font-weight: bold;');\n  }\n};\n\nvar withTimings = function withTimings(key, fn) {\n  start(key);\n  fn();\n  finish(key);\n};\n\nvar areLocationsEqual = function areLocationsEqual(first, second) {\n  if (first == null && second == null) {\n    return true;\n  }\n\n  if (first == null || second == null) {\n    return false;\n  }\n\n  return first.droppableId === second.droppableId && first.index === second.index;\n};\n\nvar isCriticalEqual = function isCriticalEqual(first, second) {\n  if (first === second) {\n    return true;\n  }\n\n  var isDraggableEqual = first.draggable.id === second.draggable.id && first.draggable.droppableId === second.draggable.droppableId && first.draggable.type === second.draggable.type && first.draggable.index === second.draggable.index;\n  var isDroppableEqual = first.droppable.id === second.droppable.id && first.droppable.type === second.droppable.type;\n  return isDraggableEqual && isDroppableEqual;\n};\n\nvar getExpiringAnnounce = function getExpiringAnnounce(announce) {\n  var wasCalled = false;\n  var isExpired = false;\n  setTimeout(function () {\n    isExpired = true;\n  });\n\n  var result = function result(message) {\n    if (wasCalled) {\n      if (process.env.NODE_ENV !== 'production') {\n        console.warn('Announcement already made. Not making a second announcement');\n      }\n\n      return;\n    }\n\n    if (isExpired) {\n      if (process.env.NODE_ENV !== 'production') {\n        console.warn(\"\\n          Announcements cannot be made asynchronously.\\n          Default message has already been announced.\\n        \");\n      }\n\n      return;\n    }\n\n    wasCalled = true;\n    announce(message);\n  };\n\n  result.wasCalled = function () {\n    return wasCalled;\n  };\n\n  return result;\n};\n\nvar getDragStart = function getDragStart(critical) {\n  return {\n    draggableId: critical.draggable.id,\n    type: critical.droppable.type,\n    source: {\n      droppableId: critical.droppable.id,\n      index: critical.draggable.index\n    }\n  };\n};\n\nvar hooks = function hooks(getHooks, announce) {\n  var execute = function execute(hook, data, getDefaultMessage) {\n    if (!hook) {\n      announce(getDefaultMessage(data));\n      return;\n    }\n\n    var willExpire = getExpiringAnnounce(announce);\n    var provided = {\n      announce: willExpire\n    };\n    hook(data, provided);\n\n    if (!willExpire.wasCalled()) {\n      announce(getDefaultMessage(data));\n    }\n  };\n\n  var publisher = function () {\n    var lastLocation = null;\n    var lastCritical = null;\n    var _isDragStartPublished = false;\n\n    var beforeStart = function beforeStart(critical) {\n      !!_isDragStartPublished ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot fire onBeforeDragStart as a drag start has already been published') : invariant(false) : void 0;\n      withTimings('onBeforeDragStart', function () {\n        var fn = getHooks().onBeforeDragStart;\n\n        if (fn) {\n          fn(getDragStart(critical));\n        }\n      });\n    };\n\n    var start$$1 = function start$$1(critical) {\n      !!_isDragStartPublished ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot fire onBeforeDragStart as a drag start has already been published') : invariant(false) : void 0;\n      var data = getDragStart(critical);\n      lastCritical = critical;\n      lastLocation = data.source;\n      _isDragStartPublished = true;\n      withTimings('onDragStart', function () {\n        return execute(getHooks().onDragStart, data, preset.onDragStart);\n      });\n    };\n\n    var move = function move(critical, location) {\n      !(_isDragStartPublished && lastCritical) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot fire onDragMove when onDragStart has not been called') : invariant(false) : void 0;\n      var hasCriticalChanged = !isCriticalEqual(critical, lastCritical);\n\n      if (hasCriticalChanged) {\n        lastCritical = critical;\n      }\n\n      var hasLocationChanged = !areLocationsEqual(lastLocation, location);\n\n      if (hasLocationChanged) {\n        lastLocation = location;\n      }\n\n      if (!hasCriticalChanged && !hasLocationChanged) {\n        return;\n      }\n\n      var data = _extends({}, getDragStart(critical), {\n        destination: location\n      });\n\n      withTimings('onDragUpdate', function () {\n        return execute(getHooks().onDragUpdate, data, preset.onDragUpdate);\n      });\n    };\n\n    var drop = function drop(result) {\n      !_isDragStartPublished ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot fire onDragEnd when there is no matching onDragStart') : invariant(false) : void 0;\n      _isDragStartPublished = false;\n      lastLocation = null;\n      lastCritical = null;\n      withTimings('onDragEnd', function () {\n        return execute(getHooks().onDragEnd, result, preset.onDragEnd);\n      });\n    };\n\n    var abort = function abort() {\n      !(_isDragStartPublished && lastCritical) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot cancel when onDragStart not fired') : invariant(false) : void 0;\n\n      var result = _extends({}, getDragStart(lastCritical), {\n        destination: null,\n        reason: 'CANCEL'\n      });\n\n      drop(result);\n    };\n\n    return {\n      beforeStart: beforeStart,\n      start: start$$1,\n      move: move,\n      drop: drop,\n      abort: abort,\n      isDragStartPublished: function isDragStartPublished() {\n        return _isDragStartPublished;\n      }\n    };\n  }();\n\n  return function (store) {\n    return function (next) {\n      return function (action) {\n        if (action.type === 'INITIAL_PUBLISH') {\n          var critical = action.payload.critical;\n          publisher.beforeStart(critical);\n          next(action);\n          publisher.start(critical);\n          return;\n        }\n\n        next(action);\n\n        if (action.type === 'DROP_COMPLETE') {\n          var result = action.payload;\n          publisher.drop(result);\n          return;\n        }\n\n        if (action.type === 'CLEAN') {\n          if (publisher.isDragStartPublished()) {\n            publisher.abort();\n          }\n\n          return;\n        }\n\n        if (!publisher.isDragStartPublished()) {\n          return;\n        }\n\n        var state = store.getState();\n\n        if (state.phase === 'DRAGGING') {\n          publisher.move(state.critical, state.impact.destination);\n        }\n      };\n    };\n  };\n};\n\nvar dropAnimationFinish = function dropAnimationFinish(store) {\n  return function (next) {\n    return function (action) {\n      if (action.type !== 'DROP_ANIMATION_FINISHED') {\n        next(action);\n        return;\n      }\n\n      var state = store.getState();\n      !(state.phase === 'DROP_ANIMATING') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot finish a drop animating when no drop is occurring') : invariant(false) : void 0;\n      store.dispatch(completeDrop(state.pending.result));\n    };\n  };\n};\n\nvar dimensionMarshalStopper = function dimensionMarshalStopper(getMarshal) {\n  return function () {\n    return function (next) {\n      return function (action) {\n        if (action.type === 'DROP_COMPLETE' || action.type === 'CLEAN' || action.type === 'DROP_ANIMATE') {\n          var marshal = getMarshal();\n          marshal.stopPublishing();\n        }\n\n        next(action);\n      };\n    };\n  };\n};\n\nvar shouldCancel = function shouldCancel(action) {\n  return action.type === 'CANCEL' || action.type === 'DROP_ANIMATE' || action.type === 'DROP' || action.type === 'DROP_COMPLETE' || action.type === 'COLLECTION_STARTING';\n};\n\nvar autoScroll = function autoScroll(getScroller) {\n  return function (store) {\n    return function (next) {\n      return function (action) {\n        if (shouldCancel(action)) {\n          getScroller().cancel();\n          next(action);\n          return;\n        }\n\n        next(action);\n        var state = store.getState();\n\n        if (state.phase !== 'DRAGGING') {\n          return;\n        }\n\n        if (state.autoScrollMode === 'FLUID') {\n          getScroller().fluidScroll(state);\n          return;\n        }\n\n        if (!state.scrollJumpRequest) {\n          return;\n        }\n\n        getScroller().jumpScroll(state);\n      };\n    };\n  };\n};\n\nvar shouldCheckOnAction = function shouldCheckOnAction(action) {\n  return action.type === 'MOVE' || action.type === 'MOVE_UP' || action.type === 'MOVE_RIGHT' || action.type === 'MOVE_DOWN' || action.type === 'MOVE_LEFT' || action.type === 'MOVE_BY_WINDOW_SCROLL';\n};\n\nvar hasDroppableOverChanged = function hasDroppableOverChanged(previous, current) {\n  if (!previous) {\n    return Boolean(current);\n  }\n\n  if (!current) {\n    return Boolean(previous);\n  }\n\n  return previous.droppableId !== current.droppableId;\n};\n\nvar getNewMaxScroll = function getNewMaxScroll(previous, current, action) {\n  if (!shouldCheckOnAction(action)) {\n    return null;\n  }\n\n  if (!isMovementAllowed(previous) || !isMovementAllowed(current)) {\n    return null;\n  }\n\n  if (!hasDroppableOverChanged(previous.impact.destination, current.impact.destination)) {\n    return null;\n  }\n\n  var viewport = current.viewport;\n  var doc = document.documentElement;\n  !doc ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Could not find document.documentElement') : invariant(false) : void 0;\n  var maxScroll = getMaxScroll({\n    scrollHeight: doc.scrollHeight,\n    scrollWidth: doc.scrollWidth,\n    width: viewport.frame.width,\n    height: viewport.frame.height\n  });\n\n  if (isEqual(maxScroll, viewport.scroll.max)) {\n    return null;\n  }\n\n  return maxScroll;\n};\n\nvar maxScrollUpdater = function maxScrollUpdater(store) {\n  return function (next) {\n    return function (action) {\n      var previous = store.getState();\n      next(action);\n      var current = store.getState();\n      var maxScroll = getNewMaxScroll(previous, current, action);\n\n      if (maxScroll) {\n        next(updateViewportMaxScroll(maxScroll));\n      }\n    };\n  };\n};\n\nvar composeEnhancers = typeof window === 'object' && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : compose;\n\nvar createStore$1 = function createStore$1(_ref) {\n  var getDimensionMarshal = _ref.getDimensionMarshal,\n      styleMarshal = _ref.styleMarshal,\n      getHooks = _ref.getHooks,\n      announce = _ref.announce,\n      getScroller = _ref.getScroller;\n  return createStore(reducer, composeEnhancers(applyMiddleware(style(styleMarshal), dimensionMarshalStopper(getDimensionMarshal), lift$1(getDimensionMarshal), drop$1, dropAnimationFinish, maxScrollUpdater, autoScroll(getScroller), hooks(getHooks, announce))));\n};\n\nvar getEmptyMap = function getEmptyMap() {\n  return {\n    draggables: {},\n    droppables: {}\n  };\n};\n\nvar timingKey = 'Publish collection from DOM';\n\nvar createPublisher = function createPublisher(_ref) {\n  var getProvided = _ref.getProvided,\n      callbacks = _ref.callbacks;\n\n  var advancedUsageWarning = function () {\n    if (process.env.NODE_ENV === 'production') {\n      return function () {};\n    }\n\n    var hasAnnounced = false;\n    return function () {\n      if (hasAnnounced) {\n        return;\n      }\n\n      hasAnnounced = true;\n\n      if (process.env.NODE_ENV === 'production') {\n        return;\n      }\n\n      console.warn(\"\\n        Advanced usage warning: you are adding or removing a dimension during a drag\\n        This an advanced feature used to support dynamic interactions such as lazy loading lists.\\n\\n        Keep in mind the following restrictions:\\n\\n        - Draggable's can only be added to Droppable's that are scroll containers\\n        - Adding a Droppable cannot impact the placement of other Droppables\\n          (it cannot push a Droppable on the page)\\n\\n        (This warning will be stripped in production builds)\\n      \".trim());\n    };\n  }();\n\n  var additions = getEmptyMap();\n  var removals = getEmptyMap();\n  var frameId = null;\n\n  var reset = function reset() {\n    additions = getEmptyMap();\n    removals = getEmptyMap();\n  };\n\n  var collect = function collect() {\n    advancedUsageWarning();\n\n    if (frameId) {\n      return;\n    }\n\n    frameId = requestAnimationFrame(function () {\n      frameId = null;\n      callbacks.collectionStarting();\n      start(timingKey);\n\n      var _getProvided = getProvided(),\n          entries = _getProvided.entries,\n          collection = _getProvided.collection;\n\n      var windowScroll = collection.initialWindowScroll;\n\n      var draggables = _Object$keys(additions.draggables).map(function (id) {\n        return entries.draggables[id].getDimension(windowScroll);\n      });\n\n      var droppables = _Object$keys(additions.droppables).map(function (id) {\n        return entries.droppables[id].callbacks.getDimensionAndWatchScroll(windowScroll, collection.scrollOptions);\n      });\n\n      var result = {\n        additions: {\n          draggables: draggables,\n          droppables: droppables\n        },\n        removals: {\n          draggables: _Object$keys(removals.draggables),\n          droppables: _Object$keys(removals.droppables)\n        }\n      };\n      reset();\n      finish(timingKey);\n      callbacks.publish(result);\n    });\n  };\n\n  var addDraggable = function addDraggable(id) {\n    additions.draggables[id] = true;\n\n    if (removals.draggables[id]) {\n      delete removals.draggables[id];\n    }\n\n    collect();\n  };\n\n  var removeDraggable = function removeDraggable(id) {\n    removals.draggables[id] = true;\n\n    if (additions.draggables[id]) {\n      delete additions.draggables[id];\n    }\n\n    collect();\n  };\n\n  var addDroppable = function addDroppable(id) {\n    additions.droppables[id] = true;\n\n    if (removals.droppables[id]) {\n      delete removals.droppables[id];\n    }\n\n    collect();\n  };\n\n  var removeDroppable = function removeDroppable(id) {\n    removals.droppables[id] = true;\n\n    if (additions.droppables[id]) {\n      delete additions.droppables[id];\n    }\n\n    collect();\n  };\n\n  var stop = function stop() {\n    if (!frameId) {\n      return;\n    }\n\n    cancelAnimationFrame(frameId);\n    frameId = null;\n    reset();\n  };\n\n  return {\n    addDraggable: addDraggable,\n    removeDraggable: removeDraggable,\n    addDroppable: addDroppable,\n    removeDroppable: removeDroppable,\n    stop: stop\n  };\n};\n\nvar createDimensionMarshal = function createDimensionMarshal(callbacks) {\n  var entries = {\n    droppables: {},\n    draggables: {}\n  };\n  var collection = null;\n  var publisher = createPublisher({\n    callbacks: {\n      publish: callbacks.publish,\n      collectionStarting: callbacks.collectionStarting\n    },\n    getProvided: function getProvided() {\n      !collection ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot get scroll options when there is no collection') : invariant(false) : void 0;\n      return {\n        entries: entries,\n        collection: collection\n      };\n    }\n  });\n\n  var registerDraggable = function registerDraggable(descriptor, getDimension) {\n    var entry = {\n      descriptor: descriptor,\n      getDimension: getDimension\n    };\n    entries.draggables[descriptor.id] = entry;\n\n    if (!collection) {\n      return;\n    }\n\n    if (collection.critical.draggable.type !== descriptor.type) {\n      return;\n    }\n\n    publisher.addDraggable(descriptor.id);\n  };\n\n  var updateDraggable = function updateDraggable(previous, descriptor, getDimension) {\n    !entries.draggables[previous.id] ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot update draggable registration as no previous registration was found') : invariant(false) : void 0;\n    delete entries.draggables[previous.id];\n    var entry = {\n      descriptor: descriptor,\n      getDimension: getDimension\n    };\n    entries.draggables[descriptor.id] = entry;\n  };\n\n  var unregisterDraggable = function unregisterDraggable(descriptor) {\n    var entry = entries.draggables[descriptor.id];\n    !entry ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Cannot unregister Draggable with id \" + descriptor.id + \" as it is not registered\") : invariant(false) : void 0;\n\n    if (entry.descriptor !== descriptor) {\n      return;\n    }\n\n    delete entries.draggables[descriptor.id];\n\n    if (!collection) {\n      return;\n    }\n\n    !(collection.critical.draggable.id !== descriptor.id) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot remove the dragging item during a drag') : invariant(false) : void 0;\n\n    if (descriptor.type !== collection.critical.draggable.type) {\n      return;\n    }\n\n    publisher.removeDraggable(descriptor.id);\n  };\n\n  var registerDroppable = function registerDroppable(descriptor, droppableCallbacks) {\n    var id = descriptor.id;\n    entries.droppables[id] = {\n      descriptor: descriptor,\n      callbacks: droppableCallbacks\n    };\n\n    if (!collection) {\n      return;\n    }\n\n    if (descriptor.type !== collection.critical.droppable.type) {\n      return;\n    }\n\n    publisher.addDroppable(id);\n  };\n\n  var updateDroppable = function updateDroppable(previous, descriptor, droppableCallbacks) {\n    !entries.droppables[previous.id] ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot update droppable registration as no previous registration was found') : invariant(false) : void 0;\n    delete entries.droppables[previous.id];\n    var entry = {\n      descriptor: descriptor,\n      callbacks: droppableCallbacks\n    };\n    entries.droppables[descriptor.id] = entry;\n\n    if (collection) {\n      process.env.NODE_ENV !== \"production\" ? invariant(false, 'You are not able to update the id or type of a droppable during a drag') : invariant(false);\n    }\n  };\n\n  var unregisterDroppable = function unregisterDroppable(descriptor) {\n    var entry = entries.droppables[descriptor.id];\n    !entry ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Cannot unregister Droppable with id \" + descriptor.id + \" as as it is not registered\") : invariant(false) : void 0;\n\n    if (entry.descriptor !== descriptor) {\n      return;\n    }\n\n    delete entries.droppables[descriptor.id];\n\n    if (!collection) {\n      return;\n    }\n\n    !(collection.critical.droppable.id !== descriptor.id) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot remove the home Droppable during a drag') : invariant(false) : void 0;\n\n    if (collection.critical.droppable.type !== descriptor.type) {\n      return;\n    }\n\n    publisher.removeDroppable(descriptor.id);\n  };\n\n  var updateDroppableIsEnabled = function updateDroppableIsEnabled(id, isEnabled) {\n    !entries.droppables[id] ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Cannot update the scroll on Droppable \" + id + \" as it is not registered\") : invariant(false) : void 0;\n\n    if (!collection) {\n      return;\n    }\n\n    callbacks.updateDroppableIsEnabled({\n      id: id,\n      isEnabled: isEnabled\n    });\n  };\n\n  var updateDroppableScroll = function updateDroppableScroll(id, newScroll) {\n    !entries.droppables[id] ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Cannot update the scroll on Droppable \" + id + \" as it is not registered\") : invariant(false) : void 0;\n\n    if (!collection) {\n      return;\n    }\n\n    callbacks.updateDroppableScroll({\n      id: id,\n      offset: newScroll\n    });\n  };\n\n  var scrollDroppable = function scrollDroppable(id, change) {\n    var entry = entries.droppables[id];\n    !entry ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Cannot scroll Droppable \" + id + \" as it is not registered\") : invariant(false) : void 0;\n\n    if (!collection) {\n      return;\n    }\n\n    entry.callbacks.scroll(change);\n  };\n\n  var getInitialPublish = function getInitialPublish(args) {\n    var critical = args.critical,\n        scrollOptions = args.scrollOptions,\n        windowScroll = args.initialWindowScroll;\n    var timingKey = 'Initial collection from DOM';\n    start(timingKey);\n    var home = critical.droppable;\n\n    var droppables = _Object$keys(entries.droppables).map(function (id) {\n      return entries.droppables[id];\n    }).filter(function (entry) {\n      return entry.descriptor.type === home.type;\n    }).map(function (entry) {\n      return entry.callbacks.getDimensionAndWatchScroll(windowScroll, scrollOptions);\n    }).reduce(function (previous, dimension) {\n      previous[dimension.descriptor.id] = dimension;\n      return previous;\n    }, {});\n\n    var draggables = _Object$keys(entries.draggables).map(function (id) {\n      return entries.draggables[id];\n    }).filter(function (entry) {\n      return entry.descriptor.type === critical.draggable.type;\n    }).map(function (entry) {\n      return entry.getDimension(windowScroll);\n    }).reduce(function (previous, dimension) {\n      previous[dimension.descriptor.id] = dimension;\n      return previous;\n    }, {});\n\n    finish(timingKey);\n    var dimensions = {\n      draggables: draggables,\n      droppables: droppables\n    };\n    var result = {\n      dimensions: dimensions,\n      critical: critical\n    };\n    return result;\n  };\n\n  var stopPublishing = function stopPublishing() {\n    if (!collection) {\n      return;\n    }\n\n    publisher.stop();\n    var home = collection.critical.droppable;\n\n    _Object$keys(entries.droppables).filter(function (id) {\n      return entries.droppables[id].descriptor.type === home.type;\n    }).forEach(function (id) {\n      return entries.droppables[id].callbacks.unwatchScroll();\n    });\n\n    collection = null;\n  };\n\n  var startPublishing = function startPublishing(request, windowScroll) {\n    !!collection ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot start capturing critical dimensions as there is already a collection') : invariant(false) : void 0;\n    var entry = entries.draggables[request.draggableId];\n    !entry ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot find critical draggable entry') : invariant(false) : void 0;\n    var home = entries.droppables[entry.descriptor.droppableId];\n    !home ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot find critical droppable entry') : invariant(false) : void 0;\n    var critical = {\n      draggable: entry.descriptor,\n      droppable: home.descriptor\n    };\n    collection = {\n      scrollOptions: request.scrollOptions,\n      critical: critical,\n      initialWindowScroll: windowScroll\n    };\n    return getInitialPublish(collection);\n  };\n\n  var marshal = {\n    registerDraggable: registerDraggable,\n    updateDraggable: updateDraggable,\n    unregisterDraggable: unregisterDraggable,\n    registerDroppable: registerDroppable,\n    updateDroppable: updateDroppable,\n    unregisterDroppable: unregisterDroppable,\n    updateDroppableIsEnabled: updateDroppableIsEnabled,\n    scrollDroppable: scrollDroppable,\n    updateDroppableScroll: updateDroppableScroll,\n    startPublishing: startPublishing,\n    stopPublishing: stopPublishing\n  };\n  return marshal;\n};\n\nvar physics = function () {\n  var base = {\n    stiffness: 1000,\n    damping: 60,\n    precision: 0.99\n  };\n\n  var standard = _extends({}, base);\n\n  var fast = _extends({}, base, {\n    stiffness: base.stiffness * 2\n  });\n\n  return {\n    standard: standard,\n    fast: fast\n  };\n}();\n\nvar css = {\n  outOfTheWay: 'transform 0.2s cubic-bezier(0.2, 0, 0, 1)'\n};\nvar prefix = 'data-react-beautiful-dnd';\nvar dragHandle = prefix + \"-drag-handle\";\nvar draggable = prefix + \"-draggable\";\nvar droppable = prefix + \"-droppable\";\n\nvar getStyles = function getStyles(styleContext) {\n  var dragHandleSelector = \"[\" + dragHandle + \"=\\\"\" + styleContext + \"\\\"]\";\n  var draggableSelector = \"[\" + draggable + \"=\\\"\" + styleContext + \"\\\"]\";\n  var droppableSelector = \"[\" + droppable + \"=\\\"\" + styleContext + \"\\\"]\";\n  var dragHandleStyles = {\n    base: \"\\n      \" + dragHandleSelector + \" {\\n        -webkit-touch-callout: none;\\n        -webkit-tap-highlight-color: rgba(0,0,0,0);\\n        touch-action: manipulation;\\n      }\\n    \",\n    grabCursor: \"\\n      \" + dragHandleSelector + \" {\\n        cursor: -webkit-grab;\\n        cursor: grab;\\n      }\\n    \",\n    blockPointerEvents: \"\\n      \" + dragHandleSelector + \" {\\n        pointer-events: none;\\n      }\\n    \"\n  };\n  var draggableStyles = {\n    animateMovement: \"\\n      \" + draggableSelector + \" {\\n        transition: \" + css.outOfTheWay + \";\\n      }\\n    \"\n  };\n  var droppableStyles = {\n    base: \"\\n      \" + droppableSelector + \" {\\n        overflow-anchor: none;\\n      }\\n    \"\n  };\n  var bodyStyles = {\n    whileActiveDragging: \"\\n      body {\\n        cursor: grabbing;\\n        cursor: -webkit-grabbing;\\n        user-select: none;\\n        -webkit-user-select: none;\\n        -moz-user-select: none;\\n        -ms-user-select: none;\\n      }\\n    \"\n  };\n  var base = [dragHandleStyles.base, droppableStyles.base];\n  var resting = base.concat([dragHandleStyles.grabCursor]);\n  var collecting = base.concat([dragHandleStyles.blockPointerEvents, bodyStyles.whileActiveDragging]);\n  var dragging = collecting.concat([draggableStyles.animateMovement]);\n  var dropAnimating = base.concat([dragHandleStyles.grabCursor, draggableStyles.animateMovement]);\n  var userCancel = base.concat([draggableStyles.animateMovement]);\n  return {\n    resting: resting.join(''),\n    dragging: dragging.join(''),\n    dropAnimating: dropAnimating.join(''),\n    collecting: collecting.join(''),\n    userCancel: userCancel.join('')\n  };\n};\n\nvar count = 0;\n\nvar resetStyleContext = function resetStyleContext() {\n  count = 0;\n};\n\nvar getHead = function getHead() {\n  var head = document.querySelector('head');\n  !head ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot find the head to append a style to') : invariant(false) : void 0;\n  return head;\n};\n\nvar createStyleMarshal = function createStyleMarshal() {\n  var context = \"\" + count++;\n  var styles = getStyles(context);\n  var el = null;\n  var setStyle = memoizeOne(function (proposed) {\n    !el ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot set style of style tag if not mounted') : invariant(false) : void 0;\n    el.innerHTML = proposed;\n  });\n\n  var mount = function mount() {\n    !!el ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Style marshal already mounted') : invariant(false) : void 0;\n    el = document.createElement('style');\n    el.type = 'text/css';\n    el.setAttribute(prefix, context);\n    getHead().appendChild(el);\n    setStyle(styles.resting);\n  };\n\n  var collecting = function collecting() {\n    return setStyle(styles.collecting);\n  };\n\n  var dragging = function dragging() {\n    return setStyle(styles.dragging);\n  };\n\n  var dropping = function dropping(reason) {\n    if (reason === 'DROP') {\n      setStyle(styles.dropAnimating);\n      return;\n    }\n\n    setStyle(styles.userCancel);\n  };\n\n  var resting = function resting() {\n    return setStyle(styles.resting);\n  };\n\n  var unmount = function unmount() {\n    !el ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot unmount style marshal as it is already unmounted') : invariant(false) : void 0;\n    getHead().removeChild(el);\n    el = null;\n  };\n\n  var marshal = {\n    collecting: collecting,\n    dragging: dragging,\n    dropping: dropping,\n    resting: resting,\n    styleContext: context,\n    mount: mount,\n    unmount: unmount\n  };\n  return marshal;\n};\n\nvar canStartDrag = function canStartDrag(state, id) {\n  if (state.phase === 'IDLE') {\n    return true;\n  }\n\n  if (state.phase !== 'DROP_ANIMATING') {\n    return false;\n  }\n\n  if (state.pending.result.draggableId === id) {\n    return false;\n  }\n\n  return state.pending.result.reason === 'DROP';\n};\n\nvar scrollWindow = function scrollWindow(change) {\n  window.scrollBy(change.x, change.y);\n};\n\nvar count$1 = 0;\nvar visuallyHidden = {\n  position: 'absolute',\n  width: '1px',\n  height: '1px',\n  margin: '-1px',\n  border: '0',\n  padding: '0',\n  overflow: 'hidden',\n  clip: 'rect(0 0 0 0)',\n  'clip-path': 'inset(100%)'\n};\n\nvar getBody = function getBody() {\n  !document.body ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Announcer cannot find document.body') : invariant(false) : void 0;\n  return document.body;\n};\n\nvar createAnnouncer = function createAnnouncer() {\n  var id = \"react-beautiful-dnd-announcement-\" + count$1++;\n  var el = null;\n\n  var announce = function announce(message) {\n    !el ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot announce to unmounted node') : invariant(false) : void 0;\n    el.textContent = message;\n  };\n\n  var mount = function mount() {\n    !!el ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Announcer already mounted') : invariant(false) : void 0;\n    el = document.createElement('div');\n    el.id = id;\n    el.setAttribute('aria-live', 'assertive');\n    el.setAttribute('role', 'log');\n    el.setAttribute('aria-atomic', 'true');\n\n    _Object$assign(el.style, visuallyHidden);\n\n    getBody().appendChild(el);\n  };\n\n  var unmount = function unmount() {\n    !el ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Will not unmount annoucer as it is already unmounted') : invariant(false) : void 0;\n    getBody().removeChild(el);\n    el = null;\n  };\n\n  var announcer = {\n    announce: announce,\n    id: id,\n    mount: mount,\n    unmount: unmount\n  };\n  return announcer;\n};\n\nvar getScrollableDroppables = memoizeOne(function (droppables) {\n  return toDroppableList(droppables).filter(function (droppable) {\n    if (!droppable.isEnabled) {\n      return false;\n    }\n\n    if (!droppable.viewport.closestScrollable) {\n      return false;\n    }\n\n    return true;\n  });\n});\n\nvar getScrollableDroppableOver = function getScrollableDroppableOver(target, droppables) {\n  var maybe = getScrollableDroppables(droppables).find(function (droppable) {\n    !droppable.viewport.closestScrollable ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Invalid result') : invariant(false) : void 0;\n    return isPositionInFrame(droppable.viewport.closestScrollable.framePageMarginBox)(target);\n  });\n  return maybe;\n};\n\nvar getBestScrollableDroppable = function getBestScrollableDroppable(_ref) {\n  var center = _ref.center,\n      destination = _ref.destination,\n      droppables = _ref.droppables;\n\n  if (destination) {\n    var _dimension = droppables[destination.droppableId];\n\n    if (!_dimension.viewport.closestScrollable) {\n      return null;\n    }\n\n    return _dimension;\n  }\n\n  var dimension = getScrollableDroppableOver(center, droppables);\n  return dimension;\n};\n\nvar smallestSigned = apply(function (value) {\n  if (value === 0) {\n    return 0;\n  }\n\n  return value > 0 ? 1 : -1;\n});\n\nvar getOverlap = function () {\n  var getRemainder = function getRemainder(target, max) {\n    if (target < 0) {\n      return target;\n    }\n\n    if (target > max) {\n      return target - max;\n    }\n\n    return 0;\n  };\n\n  return function (_ref) {\n    var current = _ref.current,\n        max = _ref.max,\n        change = _ref.change;\n    var targetScroll = add(current, change);\n    var overlap = {\n      x: getRemainder(targetScroll.x, max.x),\n      y: getRemainder(targetScroll.y, max.y)\n    };\n\n    if (isEqual(overlap, origin)) {\n      return null;\n    }\n\n    return overlap;\n  };\n}();\n\nvar canPartiallyScroll = function canPartiallyScroll(_ref2) {\n  var rawMax = _ref2.max,\n      current = _ref2.current,\n      change = _ref2.change;\n  var max = {\n    x: Math.max(current.x, rawMax.x),\n    y: Math.max(current.y, rawMax.y)\n  };\n  var smallestChange = smallestSigned(change);\n  var overlap = getOverlap({\n    max: max,\n    current: current,\n    change: smallestChange\n  });\n\n  if (!overlap) {\n    return true;\n  }\n\n  if (smallestChange.x !== 0 && overlap.x === 0) {\n    return true;\n  }\n\n  if (smallestChange.y !== 0 && overlap.y === 0) {\n    return true;\n  }\n\n  return false;\n};\n\nvar canScrollWindow = function canScrollWindow(viewport, change) {\n  return canPartiallyScroll({\n    current: viewport.scroll.current,\n    max: viewport.scroll.max,\n    change: change\n  });\n};\n\nvar getWindowOverlap = function getWindowOverlap(viewport, change) {\n  if (!canScrollWindow(viewport, change)) {\n    return null;\n  }\n\n  var max = viewport.scroll.max;\n  var current = viewport.scroll.current;\n  return getOverlap({\n    current: current,\n    max: max,\n    change: change\n  });\n};\n\nvar canScrollDroppable = function canScrollDroppable(droppable, change) {\n  var closest$$1 = droppable.viewport.closestScrollable;\n\n  if (!closest$$1) {\n    return false;\n  }\n\n  return canPartiallyScroll({\n    current: closest$$1.scroll.current,\n    max: closest$$1.scroll.max,\n    change: change\n  });\n};\n\nvar getDroppableOverlap = function getDroppableOverlap(droppable, change) {\n  var closest$$1 = droppable.viewport.closestScrollable;\n\n  if (!closest$$1) {\n    return null;\n  }\n\n  if (!canScrollDroppable(droppable, change)) {\n    return null;\n  }\n\n  return getOverlap({\n    current: closest$$1.scroll.current,\n    max: closest$$1.scroll.max,\n    change: change\n  });\n};\n\nvar config = {\n  startFrom: 0.25,\n  maxSpeedAt: 0.05,\n  maxScrollSpeed: 28,\n  ease: function ease(percentage) {\n    return Math.pow(percentage, 2);\n  }\n};\nvar clean$1 = apply(function (value) {\n  return value === 0 ? 0 : value;\n});\n\nvar getPixelThresholds = function getPixelThresholds(container, axis) {\n  var startFrom = container[axis.size] * config.startFrom;\n  var maxSpeedAt = container[axis.size] * config.maxSpeedAt;\n  var accelerationPlane = startFrom - maxSpeedAt;\n  var thresholds = {\n    startFrom: startFrom,\n    maxSpeedAt: maxSpeedAt,\n    accelerationPlane: accelerationPlane\n  };\n  return thresholds;\n};\n\nvar getSpeed = function getSpeed(distance$$1, thresholds) {\n  if (distance$$1 >= thresholds.startFrom) {\n    return 0;\n  }\n\n  if (distance$$1 <= thresholds.maxSpeedAt) {\n    return config.maxScrollSpeed;\n  }\n\n  var distancePastStart = thresholds.startFrom - distance$$1;\n  var percentage = distancePastStart / thresholds.accelerationPlane;\n  var transformed = config.ease(percentage);\n  var speed = config.maxScrollSpeed * transformed;\n  return speed;\n};\n\nvar adjustForSizeLimits = function adjustForSizeLimits(_ref) {\n  var container = _ref.container,\n      subject = _ref.subject,\n      proposedScroll = _ref.proposedScroll;\n  var isTooBigVertically = subject.height > container.height;\n  var isTooBigHorizontally = subject.width > container.width;\n\n  if (!isTooBigHorizontally && !isTooBigVertically) {\n    return proposedScroll;\n  }\n\n  if (isTooBigHorizontally && isTooBigVertically) {\n    return null;\n  }\n\n  return {\n    x: isTooBigHorizontally ? 0 : proposedScroll.x,\n    y: isTooBigVertically ? 0 : proposedScroll.y\n  };\n};\n\nvar getRequiredScroll = function getRequiredScroll(_ref2) {\n  var container = _ref2.container,\n      subject = _ref2.subject,\n      center = _ref2.center;\n  var distance$$1 = {\n    top: center.y - container.top,\n    right: container.right - center.x,\n    bottom: container.bottom - center.y,\n    left: center.x - container.left\n  };\n\n  var y = function () {\n    var thresholds = getPixelThresholds(container, vertical);\n    var isCloserToBottom = distance$$1.bottom < distance$$1.top;\n\n    if (isCloserToBottom) {\n      return getSpeed(distance$$1.bottom, thresholds);\n    }\n\n    return -1 * getSpeed(distance$$1.top, thresholds);\n  }();\n\n  var x = function () {\n    var thresholds = getPixelThresholds(container, horizontal);\n    var isCloserToRight = distance$$1.right < distance$$1.left;\n\n    if (isCloserToRight) {\n      return getSpeed(distance$$1.right, thresholds);\n    }\n\n    return -1 * getSpeed(distance$$1.left, thresholds);\n  }();\n\n  var required = clean$1({\n    x: x,\n    y: y\n  });\n\n  if (isEqual(required, origin)) {\n    return null;\n  }\n\n  var limited = adjustForSizeLimits({\n    container: container,\n    subject: subject,\n    proposedScroll: required\n  });\n\n  if (!limited) {\n    return null;\n  }\n\n  return isEqual(limited, origin) ? null : limited;\n};\n\nvar withPlaceholder = function withPlaceholder(droppable, draggable) {\n  var closest$$1 = droppable.viewport.closestScrollable;\n\n  if (!closest$$1) {\n    return null;\n  }\n\n  var isOverHome = droppable.descriptor.id === draggable.descriptor.droppableId;\n  var max = closest$$1.scroll.max;\n  var current = closest$$1.scroll.current;\n\n  if (isOverHome) {\n    return {\n      max: max,\n      current: current\n    };\n  }\n\n  var spaceForPlaceholder = patch(droppable.axis.line, draggable.placeholder.client.borderBox[droppable.axis.size]);\n  var newMax = add(max, spaceForPlaceholder);\n  var newCurrent = {\n    x: Math.min(current.x, newMax.x),\n    y: Math.min(current.y, newMax.y)\n  };\n  return {\n    max: newMax,\n    current: newCurrent\n  };\n};\n\nvar createFluidScroller = function createFluidScroller(_ref3) {\n  var scrollWindow = _ref3.scrollWindow,\n      scrollDroppable = _ref3.scrollDroppable;\n  var scheduleWindowScroll = rafSchd(scrollWindow);\n  var scheduleDroppableScroll = rafSchd(scrollDroppable);\n\n  var scroller = function scroller(state) {\n    var center = state.current.page.borderBoxCenter;\n    var draggable = state.dimensions.draggables[state.critical.draggable.id];\n    var subject = draggable.page.marginBox;\n    var viewport = state.viewport;\n    var requiredWindowScroll = getRequiredScroll({\n      container: viewport.frame,\n      subject: subject,\n      center: center\n    });\n\n    if (requiredWindowScroll && canScrollWindow(viewport, requiredWindowScroll)) {\n      scheduleWindowScroll(requiredWindowScroll);\n      return;\n    }\n\n    var droppable = getBestScrollableDroppable({\n      center: center,\n      destination: state.impact.destination,\n      droppables: state.dimensions.droppables\n    });\n\n    if (!droppable) {\n      return;\n    }\n\n    var closestScrollable = droppable.viewport.closestScrollable;\n\n    if (!closestScrollable) {\n      return;\n    }\n\n    var requiredFrameScroll = getRequiredScroll({\n      container: closestScrollable.framePageMarginBox,\n      subject: subject,\n      center: center\n    });\n\n    if (!requiredFrameScroll) {\n      return;\n    }\n\n    var result = withPlaceholder(droppable, draggable);\n\n    if (!result) {\n      return;\n    }\n\n    var closest$$1 = droppable.viewport.closestScrollable;\n\n    if (!closest$$1) {\n      return;\n    }\n\n    var canScrollDroppable$$1 = canPartiallyScroll({\n      current: result.current,\n      max: result.max,\n      change: requiredFrameScroll\n    });\n\n    if (canScrollDroppable$$1) {\n      scheduleDroppableScroll(droppable.descriptor.id, requiredFrameScroll);\n    }\n  };\n\n  scroller.cancel = function () {\n    scheduleWindowScroll.cancel();\n    scheduleDroppableScroll.cancel();\n  };\n\n  return scroller;\n};\n\nvar createJumpScroller = function createJumpScroller(_ref) {\n  var move = _ref.move,\n      scrollDroppable = _ref.scrollDroppable,\n      scrollWindow = _ref.scrollWindow;\n\n  var moveByOffset = function moveByOffset(state, offset) {\n    var client = add(state.current.client.selection, offset);\n    move({\n      client: client,\n      shouldAnimate: true\n    });\n  };\n\n  var scrollDroppableAsMuchAsItCan = function scrollDroppableAsMuchAsItCan(droppable, change) {\n    if (!canScrollDroppable(droppable, change)) {\n      return change;\n    }\n\n    var overlap = getDroppableOverlap(droppable, change);\n\n    if (!overlap) {\n      scrollDroppable(droppable.descriptor.id, change);\n      return null;\n    }\n\n    var whatTheDroppableCanScroll = subtract(change, overlap);\n    scrollDroppable(droppable.descriptor.id, whatTheDroppableCanScroll);\n    var remainder = subtract(change, whatTheDroppableCanScroll);\n    return remainder;\n  };\n\n  var scrollWindowAsMuchAsItCan = function scrollWindowAsMuchAsItCan(viewport, change) {\n    if (!canScrollWindow(viewport, change)) {\n      return change;\n    }\n\n    var overlap = getWindowOverlap(viewport, change);\n\n    if (!overlap) {\n      scrollWindow(change);\n      return null;\n    }\n\n    var whatTheWindowCanScroll = subtract(change, overlap);\n    scrollWindow(whatTheWindowCanScroll);\n    var remainder = subtract(change, whatTheWindowCanScroll);\n    return remainder;\n  };\n\n  var jumpScroller = function jumpScroller(state) {\n    var request = state.scrollJumpRequest;\n\n    if (!request) {\n      return;\n    }\n\n    var destination = state.impact.destination;\n    !destination ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot perform a jump scroll when there is no destination') : invariant(false) : void 0;\n    var droppableRemainder = scrollDroppableAsMuchAsItCan(state.dimensions.droppables[destination.droppableId], request);\n\n    if (!droppableRemainder) {\n      return;\n    }\n\n    var viewport = state.viewport;\n    var windowRemainder = scrollWindowAsMuchAsItCan(viewport, droppableRemainder);\n\n    if (!windowRemainder) {\n      return;\n    }\n\n    moveByOffset(state, windowRemainder);\n  };\n\n  return jumpScroller;\n};\n\nvar createAutoScroller = function createAutoScroller(_ref) {\n  var scrollDroppable = _ref.scrollDroppable,\n      scrollWindow = _ref.scrollWindow,\n      move = _ref.move;\n  var fluidScroll = createFluidScroller({\n    scrollWindow: scrollWindow,\n    scrollDroppable: scrollDroppable\n  });\n  var jumpScroll = createJumpScroller({\n    move: move,\n    scrollWindow: scrollWindow,\n    scrollDroppable: scrollDroppable\n  });\n  var marshal = {\n    cancel: fluidScroll.cancel,\n    fluidScroll: fluidScroll,\n    jumpScroll: jumpScroll\n  };\n  return marshal;\n};\n\nvar prefix$1 = function prefix(key) {\n  return \"private-react-beautiful-dnd-key-do-not-use-\" + key;\n};\n\nvar storeKey = prefix$1('store');\nvar droppableIdKey = prefix$1('droppable-id');\nvar droppableTypeKey = prefix$1('droppable-type');\nvar dimensionMarshalKey = prefix$1('dimension-marshal');\nvar styleContextKey = prefix$1('style-context');\nvar canLiftContextKey = prefix$1('can-lift');\n\nvar _DragDropContext$chil;\n\nvar resetServerContext = function resetServerContext() {\n  resetStyleContext();\n};\n\nvar printFatalDevError = function printFatalDevError(error) {\n  if (process.env.NODE_ENV === 'production') {\n    return;\n  }\n\n  console.warn(\"\\n    An error has occurred while a drag is occurring.\\n    Any existing drag will be cancelled.\\n\\n    Raw error:\\n  \");\n  console.error(error);\n};\n\nvar DragDropContext = function (_React$Component) {\n  _inheritsLoose(DragDropContext, _React$Component);\n\n  function DragDropContext(props, context) {\n    var _this;\n\n    _this = _React$Component.call(this, props, context) || this;\n    _this.store = void 0;\n    _this.dimensionMarshal = void 0;\n    _this.styleMarshal = void 0;\n    _this.autoScroller = void 0;\n    _this.announcer = void 0;\n    _this.unsubscribe = void 0;\n\n    _this.canLift = function (id) {\n      return canStartDrag(_this.store.getState(), id);\n    };\n\n    _this.onFatalError = function (error) {\n      printFatalDevError(error);\n\n      var state = _this.store.getState();\n\n      if (state.phase !== 'IDLE') {\n        _this.store.dispatch(clean());\n      }\n    };\n\n    _this.onWindowError = function (error) {\n      return _this.onFatalError(error);\n    };\n\n    _this.announcer = createAnnouncer();\n    _this.styleMarshal = createStyleMarshal();\n    _this.store = createStore$1({\n      getDimensionMarshal: function getDimensionMarshal() {\n        return _this.dimensionMarshal;\n      },\n      styleMarshal: _this.styleMarshal,\n      getHooks: function getHooks() {\n        return {\n          onBeforeDragStart: _this.props.onBeforeDragStart,\n          onDragStart: _this.props.onDragStart,\n          onDragEnd: _this.props.onDragEnd,\n          onDragUpdate: _this.props.onDragUpdate\n        };\n      },\n      announce: _this.announcer.announce,\n      getScroller: function getScroller() {\n        return _this.autoScroller;\n      }\n    });\n    var callbacks = bindActionCreators({\n      collectionStarting: collectionStarting,\n      publish: publish,\n      updateDroppableScroll: updateDroppableScroll,\n      updateDroppableIsEnabled: updateDroppableIsEnabled\n    }, _this.store.dispatch);\n    _this.dimensionMarshal = createDimensionMarshal(callbacks);\n    _this.autoScroller = createAutoScroller(_extends({\n      scrollWindow: scrollWindow,\n      scrollDroppable: _this.dimensionMarshal.scrollDroppable\n    }, bindActionCreators({\n      move: move\n    }, _this.store.dispatch)));\n    return _this;\n  }\n\n  var _proto = DragDropContext.prototype;\n\n  _proto.getChildContext = function getChildContext() {\n    var _ref;\n\n    return _ref = {}, _ref[storeKey] = this.store, _ref[dimensionMarshalKey] = this.dimensionMarshal, _ref[styleContextKey] = this.styleMarshal.styleContext, _ref[canLiftContextKey] = this.canLift, _ref;\n  };\n\n  _proto.componentDidMount = function componentDidMount() {\n    window.addEventListener('error', this.onWindowError);\n    this.styleMarshal.mount();\n    this.announcer.mount();\n  };\n\n  _proto.componentDidCatch = function componentDidCatch(error) {\n    this.onFatalError(error);\n\n    if (error.message.indexOf('Invariant failed') !== -1) {\n      this.setState({});\n      return;\n    }\n\n    throw error;\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    window.removeEventListener('error', this.onWindowError);\n    var state = this.store.getState();\n\n    if (state.phase !== 'IDLE') {\n      this.store.dispatch(clean());\n    }\n\n    this.styleMarshal.unmount();\n    this.announcer.unmount();\n  };\n\n  _proto.render = function render() {\n    return this.props.children;\n  };\n\n  return DragDropContext;\n}(React.Component);\n\nDragDropContext.childContextTypes = (_DragDropContext$chil = {}, _DragDropContext$chil[storeKey] = PropTypes.shape({\n  dispatch: PropTypes.func.isRequired,\n  subscribe: PropTypes.func.isRequired,\n  getState: PropTypes.func.isRequired\n}).isRequired, _DragDropContext$chil[dimensionMarshalKey] = PropTypes.object.isRequired, _DragDropContext$chil[styleContextKey] = PropTypes.string.isRequired, _DragDropContext$chil[canLiftContextKey] = PropTypes.func.isRequired, _DragDropContext$chil);\n\nvar isScrollable = function isScrollable() {\n  for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {\n    values[_key] = arguments[_key];\n  }\n\n  return values.some(function (value) {\n    return value === 'auto' || value === 'scroll';\n  });\n};\n\nvar isElementScrollable = function isElementScrollable(el) {\n  var style = window.getComputedStyle(el);\n  return isScrollable(style.overflow, style.overflowY, style.overflowX);\n};\n\nvar getClosestScrollable = function getClosestScrollable(el) {\n  if (el == null) {\n    return null;\n  }\n\n  if (!isElementScrollable(el)) {\n    return getClosestScrollable(el.parentElement);\n  }\n\n  return el;\n};\n\nvar _DroppableDimensionPu;\n\nvar getScroll = function getScroll(el) {\n  return {\n    x: el.scrollLeft,\n    y: el.scrollTop\n  };\n};\n\nvar checkForNestedScrollContainers = function checkForNestedScrollContainers(scrollable) {\n  if (process.env.NODE_ENV === 'production') {\n    return;\n  }\n\n  if (!scrollable) {\n    return;\n  }\n\n  var anotherScrollParent = getClosestScrollable(scrollable.parentElement);\n\n  if (!anotherScrollParent) {\n    return;\n  }\n\n  console.warn(\"\\n    Droppable: unsupported nested scroll container detected.\\n    A Droppable can only have one scroll parent (which can be itself)\\n    Nested scroll containers are currently not supported.\\n\\n    We hope to support nested scroll containers soon: https://github.com/atlassian/react-beautiful-dnd/issues/131\\n  \");\n};\n\nvar listenerOptions = {\n  passive: true\n};\n\nvar DroppableDimensionPublisher = function (_React$Component) {\n  _inheritsLoose(DroppableDimensionPublisher, _React$Component);\n\n  function DroppableDimensionPublisher(props, context) {\n    var _this;\n\n    _this = _React$Component.call(this, props, context) || this;\n    _this.watchingScroll = null;\n    _this.callbacks = void 0;\n    _this.publishedDescriptor = null;\n\n    _this.getClosestScroll = function () {\n      if (!_this.watchingScroll) {\n        return origin;\n      }\n\n      return getScroll(_this.watchingScroll.closestScrollable);\n    };\n\n    _this.memoizedUpdateScroll = memoizeOne(function (x, y) {\n      !_this.publishedDescriptor ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot update scroll on unpublished droppable') : invariant(false) : void 0;\n      var newScroll = {\n        x: x,\n        y: y\n      };\n      var marshal = _this.context[dimensionMarshalKey];\n      marshal.updateDroppableScroll(_this.publishedDescriptor.id, newScroll);\n    });\n\n    _this.updateScroll = function () {\n      var offset = _this.getClosestScroll();\n\n      _this.memoizedUpdateScroll(offset.x, offset.y);\n    };\n\n    _this.scheduleScrollUpdate = rafSchd(_this.updateScroll);\n\n    _this.onClosestScroll = function () {\n      !_this.watchingScroll ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Could not find scroll options while scrolling') : invariant(false) : void 0;\n      var options = _this.watchingScroll.options;\n\n      if (options.shouldPublishImmediately) {\n        _this.updateScroll();\n\n        return;\n      }\n\n      _this.scheduleScrollUpdate();\n    };\n\n    _this.scroll = function (change) {\n      !_this.watchingScroll ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot scroll a droppable with no closest scrollable') : invariant(false) : void 0;\n      var closestScrollable = _this.watchingScroll.closestScrollable;\n      closestScrollable.scrollTop += change.y;\n      closestScrollable.scrollLeft += change.x;\n    };\n\n    _this.watchScroll = function (closestScrollable, options) {\n      !!_this.watchingScroll ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Droppable cannot watch scroll as it is already watching scroll') : invariant(false) : void 0;\n\n      if (!closestScrollable) {\n        return;\n      }\n\n      _this.watchingScroll = {\n        options: options,\n        closestScrollable: closestScrollable\n      };\n      closestScrollable.addEventListener('scroll', _this.onClosestScroll, listenerOptions);\n    };\n\n    _this.unwatchScroll = function () {\n      var watching = _this.watchingScroll;\n\n      if (!watching) {\n        return;\n      }\n\n      _this.scheduleScrollUpdate.cancel();\n\n      watching.closestScrollable.removeEventListener('scroll', _this.onClosestScroll, listenerOptions);\n      _this.watchingScroll = null;\n    };\n\n    _this.getMemoizedDescriptor = memoizeOne(function (id, type) {\n      return {\n        id: id,\n        type: type\n      };\n    });\n\n    _this.publish = function () {\n      var marshal = _this.context[dimensionMarshalKey];\n\n      var descriptor = _this.getMemoizedDescriptor(_this.props.droppableId, _this.props.type);\n\n      if (!_this.publishedDescriptor) {\n        marshal.registerDroppable(descriptor, _this.callbacks);\n        _this.publishedDescriptor = descriptor;\n        return;\n      }\n\n      if (_this.publishedDescriptor === descriptor) {\n        return;\n      }\n\n      marshal.updateDroppable(_this.publishedDescriptor, descriptor, _this.callbacks);\n      _this.publishedDescriptor = descriptor;\n    };\n\n    _this.unpublish = function () {\n      !_this.publishedDescriptor ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot unpublish descriptor when none is published') : invariant(false) : void 0;\n      var marshal = _this.context[dimensionMarshalKey];\n      marshal.unregisterDroppable(_this.publishedDescriptor);\n      _this.publishedDescriptor = null;\n    };\n\n    _this.getDimensionAndWatchScroll = function (windowScroll, options) {\n      var _this$props = _this.props,\n          direction = _this$props.direction,\n          ignoreContainerClipping = _this$props.ignoreContainerClipping,\n          isDropDisabled = _this$props.isDropDisabled,\n          getDroppableRef = _this$props.getDroppableRef;\n      var targetRef = getDroppableRef();\n      var descriptor = _this.publishedDescriptor;\n      !targetRef ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot calculate a dimension when not attached to the DOM') : invariant(false) : void 0;\n      !descriptor ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot get dimension for unpublished droppable') : invariant(false) : void 0;\n      var scrollableRef = getClosestScrollable(targetRef);\n      checkForNestedScrollContainers(scrollableRef);\n\n      _this.watchScroll(scrollableRef, options);\n\n      var client = function () {\n        var base = getBox(targetRef);\n\n        if (!scrollableRef) {\n          return base;\n        }\n\n        if (targetRef !== scrollableRef) {\n          return base;\n        }\n\n        var top = base.paddingBox.top - scrollableRef.scrollTop;\n        var left = base.paddingBox.left - scrollableRef.scrollLeft;\n        var bottom = top + scrollableRef.scrollHeight;\n        var right = left + scrollableRef.scrollWidth;\n        var paddingBox = {\n          top: top,\n          right: right,\n          bottom: bottom,\n          left: left\n        };\n        var borderBox = {\n          top: paddingBox.top - base.border.top,\n          right: paddingBox.right + base.border.right,\n          bottom: paddingBox.bottom + base.border.bottom,\n          left: paddingBox.left - base.border.left\n        };\n        return createBox({\n          borderBox: borderBox,\n          margin: base.margin,\n          border: base.border,\n          padding: base.padding\n        });\n      }();\n\n      var page = withScroll(client, windowScroll);\n\n      var closest$$1 = function () {\n        if (!scrollableRef) {\n          return null;\n        }\n\n        var frameClient = getBox(scrollableRef);\n        return {\n          client: frameClient,\n          page: withScroll(frameClient),\n          scrollHeight: scrollableRef.scrollHeight,\n          scrollWidth: scrollableRef.scrollWidth,\n          scroll: getScroll(scrollableRef),\n          shouldClipSubject: !ignoreContainerClipping\n        };\n      }();\n\n      return getDroppableDimension({\n        descriptor: descriptor,\n        isEnabled: !isDropDisabled,\n        direction: direction,\n        client: client,\n        page: page,\n        closest: closest$$1\n      });\n    };\n\n    var callbacks = {\n      getDimensionAndWatchScroll: _this.getDimensionAndWatchScroll,\n      unwatchScroll: _this.unwatchScroll,\n      scroll: _this.scroll\n    };\n    _this.callbacks = callbacks;\n    return _this;\n  }\n\n  var _proto = DroppableDimensionPublisher.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    this.publish();\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {\n    this.publish();\n\n    if (this.props.isDropDisabled === prevProps.isDropDisabled) {\n      return;\n    }\n\n    var marshal = this.context[dimensionMarshalKey];\n    marshal.updateDroppableIsEnabled(this.props.droppableId, !this.props.isDropDisabled);\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    if (this.watchingScroll) {\n      if (process.env.NODE_ENV !== 'production') {\n        console.warn('Unmounting droppable while it was watching scroll');\n      }\n\n      this.unwatchScroll();\n    }\n\n    this.unpublish();\n  };\n\n  _proto.render = function render() {\n    return this.props.children;\n  };\n\n  return DroppableDimensionPublisher;\n}(React.Component);\n\nDroppableDimensionPublisher.contextTypes = (_DroppableDimensionPu = {}, _DroppableDimensionPu[dimensionMarshalKey] = PropTypes.object.isRequired, _DroppableDimensionPu);\n\nvar Placeholder = function (_PureComponent) {\n  _inheritsLoose(Placeholder, _PureComponent);\n\n  function Placeholder() {\n    return _PureComponent.apply(this, arguments) || this;\n  }\n\n  var _proto = Placeholder.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    if (this.props.onMount) {\n      this.props.onMount();\n    }\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    if (this.props.onUnmount) {\n      this.props.onUnmount();\n    }\n  };\n\n  _proto.render = function render() {\n    var placeholder = this.props.placeholder;\n    var client = placeholder.client,\n        display = placeholder.display,\n        tagName = placeholder.tagName;\n    var style = {\n      display: display,\n      boxSizing: 'border-box',\n      width: client.borderBox.width,\n      height: client.borderBox.height,\n      marginTop: client.margin.top,\n      marginRight: client.margin.right,\n      marginBottom: client.margin.bottom,\n      marginLeft: client.margin.left,\n      flexShrink: '0',\n      flexGrow: '0',\n      pointerEvents: 'none'\n    };\n    return React.createElement(tagName, {\n      style: style\n    });\n  };\n\n  return Placeholder;\n}(PureComponent);\n\nvar throwIfRefIsInvalid = function throwIfRefIsInvalid(ref) {\n  !(ref && ref instanceof HTMLElement) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"\\n    provided.innerRef has not been provided with a HTMLElement.\\n\\n    You can find a guide on using the innerRef callback functions at:\\n    https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/guides/using-inner-ref.md\\n  \") : invariant(false) : void 0;\n};\n\nvar _Droppable$contextTyp, _Droppable$childConte;\n\nvar Droppable = function (_Component) {\n  _inheritsLoose(Droppable, _Component);\n\n  function Droppable(props, context) {\n    var _this;\n\n    _this = _Component.call(this, props, context) || this;\n    _this.styleContext = void 0;\n    _this.ref = null;\n    _this.isPlaceholderMounted = false;\n\n    _this.onPlaceholderMount = function () {\n      _this.isPlaceholderMounted = true;\n    };\n\n    _this.onPlaceholderUnmount = function () {\n      _this.isPlaceholderMounted = false;\n    };\n\n    _this.setRef = function (ref) {\n      if (ref === null) {\n        return;\n      }\n\n      if (ref === _this.ref) {\n        return;\n      }\n\n      _this.ref = ref;\n      throwIfRefIsInvalid(ref);\n    };\n\n    _this.getDroppableRef = function () {\n      return _this.ref;\n    };\n\n    _this.styleContext = context[styleContextKey];\n    return _this;\n  }\n\n  var _proto = Droppable.prototype;\n\n  _proto.getChildContext = function getChildContext() {\n    var _value;\n\n    var value = (_value = {}, _value[droppableIdKey] = this.props.droppableId, _value[droppableTypeKey] = this.props.type, _value);\n    return value;\n  };\n\n  _proto.componentDidMount = function componentDidMount() {\n    throwIfRefIsInvalid(this.ref);\n    this.warnIfPlaceholderNotMounted();\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate() {\n    this.warnIfPlaceholderNotMounted();\n  };\n\n  _proto.warnIfPlaceholderNotMounted = function warnIfPlaceholderNotMounted() {\n    if (process.env.NODE_ENV === 'production') {\n      return;\n    }\n\n    if (!this.props.placeholder) {\n      return;\n    }\n\n    if (this.isPlaceholderMounted) {\n      return;\n    }\n\n    console.warn(\"\\n      Droppable setup issue: DroppableProvided > placeholder could not be found.\\n      Please be sure to add the {provided.placeholder} Node as a child of your Droppable\\n\\n      More information: https://github.com/atlassian/react-beautiful-dnd#1-provided-droppableprovided\\n    \");\n  };\n\n  _proto.getPlaceholder = function getPlaceholder() {\n    if (!this.props.placeholder) {\n      return null;\n    }\n\n    return React.createElement(Placeholder, {\n      placeholder: this.props.placeholder,\n      onMount: this.onPlaceholderMount,\n      onUnmount: this.onPlaceholderUnmount\n    });\n  };\n\n  _proto.render = function render() {\n    var _this$props = this.props,\n        children = _this$props.children,\n        direction = _this$props.direction,\n        droppableId = _this$props.droppableId,\n        ignoreContainerClipping = _this$props.ignoreContainerClipping,\n        isDraggingOver = _this$props.isDraggingOver,\n        isDropDisabled = _this$props.isDropDisabled,\n        draggingOverWith = _this$props.draggingOverWith,\n        type = _this$props.type;\n    var provided = {\n      innerRef: this.setRef,\n      placeholder: this.getPlaceholder(),\n      droppableProps: {\n        'data-react-beautiful-dnd-droppable': this.styleContext\n      }\n    };\n    var snapshot = {\n      isDraggingOver: isDraggingOver,\n      draggingOverWith: draggingOverWith\n    };\n    return React.createElement(DroppableDimensionPublisher, {\n      droppableId: droppableId,\n      type: type,\n      direction: direction,\n      ignoreContainerClipping: ignoreContainerClipping,\n      isDropDisabled: isDropDisabled,\n      getDroppableRef: this.getDroppableRef\n    }, children(provided, snapshot));\n  };\n\n  return Droppable;\n}(Component);\n\nDroppable.contextTypes = (_Droppable$contextTyp = {}, _Droppable$contextTyp[styleContextKey] = PropTypes.string.isRequired, _Droppable$contextTyp);\nDroppable.childContextTypes = (_Droppable$childConte = {}, _Droppable$childConte[droppableIdKey] = PropTypes.string.isRequired, _Droppable$childConte[droppableTypeKey] = PropTypes.string.isRequired, _Droppable$childConte);\n\nvar isStrictEqual = function isStrictEqual(a, b) {\n  return a === b;\n};\n\nvar makeMapStateToProps = function makeMapStateToProps() {\n  var getIsDraggingOver = function getIsDraggingOver(id, destination) {\n    if (!destination) {\n      return false;\n    }\n\n    return destination.droppableId === id;\n  };\n\n  var shouldUsePlaceholder = function shouldUsePlaceholder(id, descriptor, destination) {\n    if (!destination) {\n      return false;\n    }\n\n    if (id === descriptor.droppableId) {\n      return false;\n    }\n\n    return id === destination.droppableId;\n  };\n\n  var getMapProps = memoizeOne(function (isDraggingOver, draggingOverWith, placeholder) {\n    return {\n      isDraggingOver: isDraggingOver,\n      draggingOverWith: draggingOverWith,\n      placeholder: placeholder\n    };\n  });\n\n  var getDefault = function getDefault() {\n    return getMapProps(false, null, null);\n  };\n\n  var selector = function selector(state, ownProps) {\n    if (ownProps.isDropDisabled) {\n      return getDefault();\n    }\n\n    var id = ownProps.droppableId;\n\n    if (state.isDragging) {\n      var destination = state.impact.destination;\n      var isDraggingOver = getIsDraggingOver(id, destination);\n      var draggableId = state.critical.draggable.id;\n      var draggingOverWith = isDraggingOver ? draggableId : null;\n      var draggable = state.dimensions.draggables[draggableId];\n      var placeholder = shouldUsePlaceholder(id, draggable.descriptor, destination) ? draggable.placeholder : null;\n      return getMapProps(isDraggingOver, draggingOverWith, placeholder);\n    }\n\n    if (state.phase === 'DROP_ANIMATING') {\n      var _destination = state.pending.impact.destination;\n\n      var _isDraggingOver = getIsDraggingOver(id, _destination);\n\n      var _draggableId = state.pending.result.draggableId;\n\n      var _draggingOverWith = _isDraggingOver ? _draggableId : null;\n\n      var _draggable = state.dimensions.draggables[_draggableId];\n\n      var _placeholder = shouldUsePlaceholder(id, _draggable.descriptor, _destination) ? _draggable.placeholder : null;\n\n      return getMapProps(_isDraggingOver, _draggingOverWith, _placeholder);\n    }\n\n    return getDefault();\n  };\n\n  return selector;\n};\n\nvar connectedDroppable = connect(makeMapStateToProps, null, null, {\n  storeKey: storeKey,\n  pure: true,\n  areStatePropsEqual: isStrictEqual\n})(Droppable);\nconnectedDroppable.defaultProps = {\n  type: 'DEFAULT',\n  isDropDisabled: false,\n  direction: 'vertical',\n  ignoreContainerClipping: false\n};\n\nvar _DraggableDimensionPu;\n\nvar DraggableDimensionPublisher = function (_Component) {\n  _inheritsLoose(DraggableDimensionPublisher, _Component);\n\n  function DraggableDimensionPublisher() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _Component.call.apply(_Component, [this].concat(args)) || this;\n    _this.publishedDescriptor = null;\n    _this.getMemoizedDescriptor = memoizeOne(function (id, index, droppableId, type) {\n      return {\n        id: id,\n        index: index,\n        droppableId: droppableId,\n        type: type\n      };\n    });\n\n    _this.publish = function () {\n      var marshal = _this.context[dimensionMarshalKey];\n\n      var descriptor = _this.getMemoizedDescriptor(_this.props.draggableId, _this.props.index, _this.props.droppableId, _this.props.type);\n\n      if (!_this.publishedDescriptor) {\n        marshal.registerDraggable(descriptor, _this.getDimension);\n        _this.publishedDescriptor = descriptor;\n        return;\n      }\n\n      if (descriptor === _this.publishedDescriptor) {\n        return;\n      }\n\n      marshal.updateDraggable(_this.publishedDescriptor, descriptor, _this.getDimension);\n      _this.publishedDescriptor = descriptor;\n    };\n\n    _this.unpublish = function () {\n      !_this.publishedDescriptor ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot unpublish descriptor when none is published') : invariant(false) : void 0;\n      var marshal = _this.context[dimensionMarshalKey];\n      marshal.unregisterDraggable(_this.publishedDescriptor);\n      _this.publishedDescriptor = null;\n    };\n\n    _this.getDimension = function (windowScroll) {\n      var targetRef = _this.props.getDraggableRef();\n\n      var descriptor = _this.publishedDescriptor;\n      !targetRef ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'DraggableDimensionPublisher cannot calculate a dimension when not attached to the DOM') : invariant(false) : void 0;\n      !descriptor ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot get dimension for unpublished draggable') : invariant(false) : void 0;\n      var computedStyles = window.getComputedStyle(targetRef);\n      var borderBox = targetRef.getBoundingClientRect();\n      var client = calculateBox(borderBox, computedStyles);\n      var page = withScroll(client, windowScroll);\n      var placeholder = {\n        client: client,\n        tagName: targetRef.tagName.toLowerCase(),\n        display: computedStyles.display\n      };\n      var dimension = {\n        descriptor: descriptor,\n        placeholder: placeholder,\n        client: client,\n        page: page\n      };\n      return dimension;\n    };\n\n    return _this;\n  }\n\n  var _proto = DraggableDimensionPublisher.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    this.publish();\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate() {\n    this.publish();\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.unpublish();\n  };\n\n  _proto.render = function render() {\n    return this.props.children;\n  };\n\n  return DraggableDimensionPublisher;\n}(Component);\n\nDraggableDimensionPublisher.contextTypes = (_DraggableDimensionPu = {}, _DraggableDimensionPu[dimensionMarshalKey] = PropTypes.object.isRequired, _DraggableDimensionPu);\n\nvar DoubleRenderBlocker = function (_React$Component) {\n  _inheritsLoose(DoubleRenderBlocker, _React$Component);\n\n  function DoubleRenderBlocker() {\n    return _React$Component.apply(this, arguments) || this;\n  }\n\n  var _proto = DoubleRenderBlocker.prototype;\n\n  _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {\n    if (isEqual(origin, nextProps.change)) {\n      return true;\n    }\n\n    if (isEqual(this.props.change, nextProps.change)) {\n      return false;\n    }\n\n    return true;\n  };\n\n  _proto.render = function render() {\n    return this.props.children(this.props.change);\n  };\n\n  return DoubleRenderBlocker;\n}(React.Component);\n\nvar Moveable = function (_Component) {\n  _inheritsLoose(Moveable, _Component);\n\n  function Moveable() {\n    return _Component.apply(this, arguments) || this;\n  }\n\n  var _proto2 = Moveable.prototype;\n\n  _proto2.getFinal = function getFinal() {\n    var destination = this.props.destination;\n    var speed = this.props.speed;\n\n    if (speed === 'INSTANT') {\n      return destination;\n    }\n\n    var config = speed === 'FAST' ? physics.fast : physics.standard;\n    return {\n      x: spring(destination.x, config),\n      y: spring(destination.y, config)\n    };\n  };\n\n  _proto2.render = function render() {\n    var _this = this;\n\n    var final = this.getFinal();\n    return React.createElement(Motion, {\n      defaultStyle: origin,\n      style: final,\n      onRest: this.props.onMoveEnd\n    }, function (current) {\n      var _this$props = _this.props,\n          speed = _this$props.speed,\n          destination = _this$props.destination,\n          children = _this$props.children;\n      var target = speed === 'INSTANT' ? destination : current;\n      return React.createElement(DoubleRenderBlocker, {\n        change: target\n      }, children);\n    });\n  };\n\n  return Moveable;\n}(Component);\n\nMoveable.defaultProps = {\n  destination: origin\n};\n\nvar getWindowFromRef = function getWindowFromRef(ref) {\n  return ref ? ref.ownerDocument.defaultView : window;\n};\n\nvar selector = \"[\" + dragHandle + \"]\";\n\nvar isSVG = function isSVG(el) {\n  if (typeof SVGElement === 'undefined') {\n    return false;\n  }\n\n  return el instanceof SVGElement;\n};\n\nvar throwIfSVG = function throwIfSVG(el) {\n  !!isSVG(el) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"A drag handle cannot be an SVGElement: it has inconsistent focus support.\\n\\n    More information: https://github.com/atlassian/react-beautiful-dnd/tree/master/docs/guides/dragging-svgs.md\") : invariant(false) : void 0;\n};\n\nvar getDragHandleRef = function getDragHandleRef(draggableRef) {\n  if (draggableRef.hasAttribute(dragHandle)) {\n    throwIfSVG(draggableRef);\n    return draggableRef;\n  }\n\n  var el = draggableRef.querySelector(selector);\n  throwIfSVG(draggableRef);\n  !el ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"\\n      Cannot find drag handle element inside of Draggable.\\n      Please be sure to apply the {...provided.dragHandleProps} to your Draggable\\n\\n      More information: https://github.com/atlassian/react-beautiful-dnd#draggable\\n    \") : invariant(false) : void 0;\n  !(el instanceof HTMLElement) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'A drag handle must be a HTMLElement') : invariant(false) : void 0;\n  return el;\n};\n\nvar retainingFocusFor = null;\nvar listenerOptions$1 = {\n  capture: true\n};\n\nvar clearRetentionOnFocusChange = function () {\n  var isBound = false;\n\n  var bind = function bind() {\n    if (isBound) {\n      return;\n    }\n\n    isBound = true;\n    window.addEventListener('focus', onWindowFocusChange, listenerOptions$1);\n  };\n\n  var unbind = function unbind() {\n    if (!isBound) {\n      return;\n    }\n\n    isBound = false;\n    window.removeEventListener('focus', onWindowFocusChange, listenerOptions$1);\n  };\n\n  var onWindowFocusChange = function onWindowFocusChange() {\n    unbind();\n    retainingFocusFor = null;\n  };\n\n  var result = function result() {\n    return bind();\n  };\n\n  result.cancel = function () {\n    return unbind();\n  };\n\n  return result;\n}();\n\nvar retain = function retain(id) {\n  retainingFocusFor = id;\n  clearRetentionOnFocusChange();\n};\n\nvar tryRestoreFocus = function tryRestoreFocus(id, draggableRef) {\n  if (!retainingFocusFor) {\n    return;\n  }\n\n  if (id !== retainingFocusFor) {\n    return;\n  }\n\n  retainingFocusFor = null;\n  clearRetentionOnFocusChange.cancel();\n  var dragHandleRef = getDragHandleRef(draggableRef);\n\n  if (!dragHandleRef) {\n    console.warn('Could not find drag handle in the DOM to focus on it');\n    return;\n  }\n\n  dragHandleRef.focus();\n};\n\nvar retainer = {\n  retain: retain,\n  tryRestoreFocus: tryRestoreFocus\n};\nvar interactiveTagNames = {\n  input: true,\n  button: true,\n  textarea: true,\n  select: true,\n  option: true,\n  optgroup: true,\n  video: true,\n  audio: true\n};\n\nvar isAnInteractiveElement = function isAnInteractiveElement(parent, current) {\n  if (current == null) {\n    return false;\n  }\n\n  var hasAnInteractiveTag = Boolean(interactiveTagNames[current.tagName.toLowerCase()]);\n\n  if (hasAnInteractiveTag) {\n    return true;\n  }\n\n  var attribute = current.getAttribute('contenteditable');\n\n  if (attribute === 'true' || attribute === '') {\n    return true;\n  }\n\n  if (current === parent) {\n    return false;\n  }\n\n  return isAnInteractiveElement(parent, current.parentElement);\n};\n\nvar shouldAllowDraggingFromTarget = function shouldAllowDraggingFromTarget(event, props) {\n  if (props.canDragInteractiveElements) {\n    return true;\n  }\n\n  var target = event.target,\n      currentTarget = event.currentTarget;\n\n  if (!(target instanceof Element) || !(currentTarget instanceof Element)) {\n    return true;\n  }\n\n  return !isAnInteractiveElement(currentTarget, target);\n};\n\nvar createScheduler = function createScheduler(callbacks) {\n  var memoizedMove = memoizeOne(function (x, y) {\n    var point = {\n      x: x,\n      y: y\n    };\n    callbacks.onMove(point);\n  });\n  var move = rafSchd(function (point) {\n    return memoizedMove(point.x, point.y);\n  });\n  var moveUp = rafSchd(callbacks.onMoveUp);\n  var moveDown = rafSchd(callbacks.onMoveDown);\n  var moveRight = rafSchd(callbacks.onMoveRight);\n  var moveLeft = rafSchd(callbacks.onMoveLeft);\n  var windowScrollMove = rafSchd(callbacks.onWindowScroll);\n\n  var cancel = function cancel() {\n    move.cancel();\n    moveUp.cancel();\n    moveDown.cancel();\n    moveRight.cancel();\n    moveLeft.cancel();\n    windowScrollMove.cancel();\n  };\n\n  return {\n    move: move,\n    moveUp: moveUp,\n    moveDown: moveDown,\n    moveRight: moveRight,\n    moveLeft: moveLeft,\n    windowScrollMove: windowScrollMove,\n    cancel: cancel\n  };\n};\n\nvar sloppyClickThreshold = 5;\n\nvar isSloppyClickThresholdExceeded = function isSloppyClickThresholdExceeded(original, current) {\n  return Math.abs(current.x - original.x) >= sloppyClickThreshold || Math.abs(current.y - original.y) >= sloppyClickThreshold;\n};\n\nvar tab = 9;\nvar enter = 13;\nvar escape = 27;\nvar space = 32;\nvar pageUp = 33;\nvar pageDown = 34;\nvar end = 35;\nvar home = 36;\nvar arrowLeft = 37;\nvar arrowUp = 38;\nvar arrowRight = 39;\nvar arrowDown = 40;\n\nvar _preventedKeys;\n\nvar preventedKeys = (_preventedKeys = {}, _preventedKeys[enter] = true, _preventedKeys[tab] = true, _preventedKeys);\n\nvar preventStandardKeyEvents = function preventStandardKeyEvents(event) {\n  if (preventedKeys[event.keyCode]) {\n    event.preventDefault();\n  }\n};\n\nvar getOptions = function getOptions(shared, fromBinding) {\n  return _extends({}, shared, fromBinding);\n};\n\nvar bindEvents = function bindEvents(el, bindings, sharedOptions) {\n  bindings.forEach(function (binding) {\n    var options = getOptions(sharedOptions, binding.options);\n    el.addEventListener(binding.eventName, binding.fn, options);\n  });\n};\n\nvar unbindEvents = function unbindEvents(el, bindings, sharedOptions) {\n  bindings.forEach(function (binding) {\n    var options = getOptions(sharedOptions, binding.options);\n    el.removeEventListener(binding.eventName, binding.fn, options);\n  });\n};\n\nvar sharedOptions = {\n  capture: true\n};\n\nvar createPostDragEventPreventer = function createPostDragEventPreventer(getWindow) {\n  var isBound = false;\n\n  var bind = function bind() {\n    if (isBound) {\n      return;\n    }\n\n    isBound = true;\n    bindEvents(getWindow(), pointerEvents, sharedOptions);\n  };\n\n  var unbind = function unbind() {\n    if (!isBound) {\n      return;\n    }\n\n    isBound = false;\n    unbindEvents(getWindow(), pointerEvents, sharedOptions);\n  };\n\n  var pointerEvents = [{\n    eventName: 'click',\n    fn: function fn(event) {\n      event.preventDefault();\n      unbind();\n    }\n  }, {\n    eventName: 'mousedown',\n    fn: unbind\n  }, {\n    eventName: 'touchstart',\n    fn: unbind\n  }];\n\n  var preventNext = function preventNext() {\n    if (isBound) {\n      unbind();\n    }\n\n    bind();\n  };\n\n  var preventer = {\n    preventNext: preventNext,\n    abort: unbind\n  };\n  return preventer;\n};\n\nvar createEventMarshal = function createEventMarshal() {\n  var isMouseDownHandled = false;\n\n  var handle = function handle() {\n    !!isMouseDownHandled ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot handle mouse down as it is already handled') : invariant(false) : void 0;\n    isMouseDownHandled = true;\n  };\n\n  var isHandled = function isHandled() {\n    return isMouseDownHandled;\n  };\n\n  var reset = function reset() {\n    isMouseDownHandled = false;\n  };\n\n  return {\n    handle: handle,\n    isHandled: isHandled,\n    reset: reset\n  };\n};\n\nvar supportedEventName = function () {\n  var base = 'visibilitychange';\n\n  if (typeof document === 'undefined') {\n    return base;\n  }\n\n  var candidates = [base, \"ms\" + base, \"webkit\" + base, \"moz\" + base, \"o\" + base];\n  var supported = candidates.find(function (eventName) {\n    return \"on\" + eventName in document;\n  });\n  return supported || base;\n}();\n\nvar primaryButton = 0;\n\nvar noop = function noop() {};\n\nvar mouseDownMarshal = createEventMarshal();\n\nvar createMouseSensor = function createMouseSensor(_ref) {\n  var callbacks = _ref.callbacks,\n      getWindow = _ref.getWindow,\n      canStartCapturing = _ref.canStartCapturing;\n  var state = {\n    isDragging: false,\n    pending: null\n  };\n\n  var setState = function setState(newState) {\n    state = newState;\n  };\n\n  var isDragging = function isDragging() {\n    return state.isDragging;\n  };\n\n  var isCapturing = function isCapturing() {\n    return Boolean(state.pending || state.isDragging);\n  };\n\n  var schedule = createScheduler(callbacks);\n  var postDragEventPreventer = createPostDragEventPreventer(getWindow);\n\n  var startDragging = function startDragging(fn) {\n    if (fn === void 0) {\n      fn = noop;\n    }\n\n    setState({\n      pending: null,\n      isDragging: true\n    });\n    fn();\n  };\n\n  var stopDragging = function stopDragging(fn, shouldBlockClick) {\n    if (fn === void 0) {\n      fn = noop;\n    }\n\n    if (shouldBlockClick === void 0) {\n      shouldBlockClick = true;\n    }\n\n    schedule.cancel();\n    unbindWindowEvents();\n    mouseDownMarshal.reset();\n\n    if (shouldBlockClick) {\n      postDragEventPreventer.preventNext();\n    }\n\n    setState({\n      isDragging: false,\n      pending: null\n    });\n    fn();\n  };\n\n  var startPendingDrag = function startPendingDrag(point) {\n    setState({\n      pending: point,\n      isDragging: false\n    });\n    bindWindowEvents();\n  };\n\n  var stopPendingDrag = function stopPendingDrag() {\n    stopDragging(noop, false);\n  };\n\n  var kill = function kill(fn) {\n    if (fn === void 0) {\n      fn = noop;\n    }\n\n    if (state.pending) {\n      stopPendingDrag();\n      return;\n    }\n\n    stopDragging(fn);\n  };\n\n  var unmount = function unmount() {\n    kill();\n    postDragEventPreventer.abort();\n  };\n\n  var cancel = function cancel() {\n    kill(callbacks.onCancel);\n  };\n\n  var windowBindings = [{\n    eventName: 'mousemove',\n    fn: function fn(event) {\n      var button = event.button,\n          clientX = event.clientX,\n          clientY = event.clientY;\n\n      if (button !== primaryButton) {\n        return;\n      }\n\n      var point = {\n        x: clientX,\n        y: clientY\n      };\n\n      if (state.isDragging) {\n        event.preventDefault();\n        schedule.move(point);\n        return;\n      }\n\n      if (!state.pending) {\n        kill();\n        process.env.NODE_ENV !== \"production\" ? invariant(false, 'Expected there to be a pending drag') : invariant(false);\n      }\n\n      if (!isSloppyClickThresholdExceeded(state.pending, point)) {\n        return;\n      }\n\n      event.preventDefault();\n      startDragging(function () {\n        return callbacks.onLift({\n          clientSelection: point,\n          autoScrollMode: 'FLUID'\n        });\n      });\n    }\n  }, {\n    eventName: 'mouseup',\n    fn: function fn(event) {\n      if (state.pending) {\n        stopPendingDrag();\n        return;\n      }\n\n      event.preventDefault();\n      stopDragging(callbacks.onDrop);\n    }\n  }, {\n    eventName: 'mousedown',\n    fn: function fn(event) {\n      if (state.isDragging) {\n        event.preventDefault();\n      }\n\n      stopDragging(callbacks.onCancel);\n    }\n  }, {\n    eventName: 'keydown',\n    fn: function fn(event) {\n      if (!state.isDragging) {\n        cancel();\n        return;\n      }\n\n      if (event.keyCode === escape) {\n        event.preventDefault();\n        cancel();\n        return;\n      }\n\n      preventStandardKeyEvents(event);\n    }\n  }, {\n    eventName: 'resize',\n    fn: cancel\n  }, {\n    eventName: 'scroll',\n    options: {\n      passive: true,\n      capture: false\n    },\n    fn: function fn() {\n      if (state.pending) {\n        stopPendingDrag();\n        return;\n      }\n\n      schedule.windowScrollMove();\n    }\n  }, {\n    eventName: 'webkitmouseforcechanged',\n    fn: function fn(event) {\n      if (event.webkitForce == null || MouseEvent.WEBKIT_FORCE_AT_FORCE_MOUSE_DOWN == null) {\n        if (process.env.NODE_ENV !== 'production') {\n          console.warn('handling a mouse force changed event when it is not supported');\n        }\n\n        return;\n      }\n\n      var forcePressThreshold = MouseEvent.WEBKIT_FORCE_AT_FORCE_MOUSE_DOWN;\n      var isForcePressing = event.webkitForce >= forcePressThreshold;\n\n      if (isForcePressing) {\n        cancel();\n      }\n    }\n  }, {\n    eventName: supportedEventName,\n    fn: cancel\n  }];\n\n  var bindWindowEvents = function bindWindowEvents() {\n    var win = getWindow();\n    bindEvents(win, windowBindings, {\n      capture: true\n    });\n  };\n\n  var unbindWindowEvents = function unbindWindowEvents() {\n    var win = getWindow();\n    unbindEvents(win, windowBindings, {\n      capture: true\n    });\n  };\n\n  var onMouseDown = function onMouseDown(event) {\n    if (mouseDownMarshal.isHandled()) {\n      return;\n    }\n\n    !!isCapturing() ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Should not be able to perform a mouse down while a drag or pending drag is occurring') : invariant(false) : void 0;\n\n    if (!canStartCapturing(event)) {\n      return;\n    }\n\n    if (event.button !== primaryButton) {\n      return;\n    }\n\n    if (event.ctrlKey || event.metaKey || event.shiftKey || event.altKey) {\n      return;\n    }\n\n    mouseDownMarshal.handle();\n    event.preventDefault();\n    var point = {\n      x: event.clientX,\n      y: event.clientY\n    };\n    startPendingDrag(point);\n  };\n\n  var sensor = {\n    onMouseDown: onMouseDown,\n    kill: kill,\n    isCapturing: isCapturing,\n    isDragging: isDragging,\n    unmount: unmount\n  };\n  return sensor;\n};\n\nvar getBorderBoxCenterPosition = function getBorderBoxCenterPosition(el) {\n  return getRect(el.getBoundingClientRect()).center;\n};\n\nvar _scrollJumpKeys;\n\nvar scrollJumpKeys = (_scrollJumpKeys = {}, _scrollJumpKeys[pageDown] = true, _scrollJumpKeys[pageUp] = true, _scrollJumpKeys[home] = true, _scrollJumpKeys[end] = true, _scrollJumpKeys);\n\nvar noop$1 = function noop() {};\n\nvar createKeyboardSensor = function createKeyboardSensor(_ref) {\n  var callbacks = _ref.callbacks,\n      getWindow = _ref.getWindow,\n      getDraggableRef = _ref.getDraggableRef,\n      canStartCapturing = _ref.canStartCapturing;\n  var state = {\n    isDragging: false\n  };\n\n  var setState = function setState(newState) {\n    state = newState;\n  };\n\n  var startDragging = function startDragging(fn) {\n    if (fn === void 0) {\n      fn = noop$1;\n    }\n\n    setState({\n      isDragging: true\n    });\n    bindWindowEvents();\n    fn();\n  };\n\n  var stopDragging = function stopDragging(fn) {\n    if (fn === void 0) {\n      fn = noop$1;\n    }\n\n    schedule.cancel();\n    unbindWindowEvents();\n    setState({\n      isDragging: false\n    });\n    fn();\n  };\n\n  var kill = function kill() {\n    return stopDragging();\n  };\n\n  var cancel = function cancel() {\n    stopDragging(callbacks.onCancel);\n  };\n\n  var isDragging = function isDragging() {\n    return state.isDragging;\n  };\n\n  var schedule = createScheduler(callbacks);\n\n  var onKeyDown = function onKeyDown(event) {\n    if (!isDragging()) {\n      if (event.defaultPrevented) {\n        return;\n      }\n\n      if (!canStartCapturing(event)) {\n        return;\n      }\n\n      if (event.keyCode !== space) {\n        return;\n      }\n\n      var ref = getDraggableRef();\n      !ref ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot start a keyboard drag without a draggable ref') : invariant(false) : void 0;\n      var center = getBorderBoxCenterPosition(ref);\n      event.preventDefault();\n      startDragging(function () {\n        return callbacks.onLift({\n          clientSelection: center,\n          autoScrollMode: 'JUMP'\n        });\n      });\n      return;\n    }\n\n    if (event.keyCode === escape) {\n      event.preventDefault();\n      cancel();\n      return;\n    }\n\n    if (event.keyCode === space) {\n      event.preventDefault();\n      stopDragging(callbacks.onDrop);\n      return;\n    }\n\n    if (event.keyCode === arrowDown) {\n      event.preventDefault();\n      schedule.moveDown();\n      return;\n    }\n\n    if (event.keyCode === arrowUp) {\n      event.preventDefault();\n      schedule.moveUp();\n      return;\n    }\n\n    if (event.keyCode === arrowRight) {\n      event.preventDefault();\n      schedule.moveRight();\n      return;\n    }\n\n    if (event.keyCode === arrowLeft) {\n      event.preventDefault();\n      schedule.moveLeft();\n      return;\n    }\n\n    if (scrollJumpKeys[event.keyCode]) {\n      event.preventDefault();\n      return;\n    }\n\n    preventStandardKeyEvents(event);\n  };\n\n  var windowBindings = [{\n    eventName: 'mousedown',\n    fn: cancel\n  }, {\n    eventName: 'mouseup',\n    fn: cancel\n  }, {\n    eventName: 'click',\n    fn: cancel\n  }, {\n    eventName: 'touchstart',\n    fn: cancel\n  }, {\n    eventName: 'resize',\n    fn: cancel\n  }, {\n    eventName: 'wheel',\n    fn: cancel\n  }, {\n    eventName: 'scroll',\n    options: {\n      capture: false\n    },\n    fn: callbacks.onWindowScroll\n  }, {\n    eventName: supportedEventName,\n    fn: cancel\n  }];\n\n  var bindWindowEvents = function bindWindowEvents() {\n    bindEvents(getWindow(), windowBindings, {\n      capture: true\n    });\n  };\n\n  var unbindWindowEvents = function unbindWindowEvents() {\n    unbindEvents(getWindow(), windowBindings, {\n      capture: true\n    });\n  };\n\n  var sensor = {\n    onKeyDown: onKeyDown,\n    kill: kill,\n    isDragging: isDragging,\n    isCapturing: isDragging,\n    unmount: kill\n  };\n  return sensor;\n};\n\nvar timeForLongPress = 150;\nvar forcePressThreshold = 0.15;\nvar touchStartMarshal = createEventMarshal();\n\nvar noop$2 = function noop() {};\n\nvar webkitHack = function () {\n  var stub = {\n    preventTouchMove: noop$2,\n    releaseTouchMove: noop$2\n  };\n\n  if (typeof window === 'undefined') {\n    return stub;\n  }\n\n  if (!('ontouchstart' in window)) {\n    return stub;\n  }\n\n  var isBlocking = false;\n  window.addEventListener('touchmove', function (event) {\n    if (!isBlocking) {\n      return;\n    }\n\n    if (event.defaultPrevented) {\n      return;\n    }\n\n    event.preventDefault();\n  }, {\n    passive: false,\n    capture: false\n  });\n\n  var preventTouchMove = function preventTouchMove() {\n    isBlocking = true;\n  };\n\n  var releaseTouchMove = function releaseTouchMove() {\n    isBlocking = false;\n  };\n\n  return {\n    preventTouchMove: preventTouchMove,\n    releaseTouchMove: releaseTouchMove\n  };\n}();\n\nvar initial = {\n  isDragging: false,\n  pending: null,\n  hasMoved: false,\n  longPressTimerId: null\n};\n\nvar createTouchSensor = function createTouchSensor(_ref) {\n  var callbacks = _ref.callbacks,\n      getWindow = _ref.getWindow,\n      canStartCapturing = _ref.canStartCapturing;\n  var state = initial;\n\n  var setState = function setState(partial) {\n    state = _extends({}, state, partial);\n  };\n\n  var isDragging = function isDragging() {\n    return state.isDragging;\n  };\n\n  var isCapturing = function isCapturing() {\n    return Boolean(state.pending || state.isDragging || state.longPressTimerId);\n  };\n\n  var schedule = createScheduler(callbacks);\n  var postDragEventPreventer = createPostDragEventPreventer(getWindow);\n\n  var startDragging = function startDragging() {\n    var pending = state.pending;\n\n    if (!pending) {\n      kill();\n      process.env.NODE_ENV !== \"production\" ? invariant(false, 'cannot start a touch drag without a pending position') : invariant(false);\n    }\n\n    setState({\n      isDragging: true,\n      hasMoved: false,\n      pending: null,\n      longPressTimerId: null\n    });\n    callbacks.onLift({\n      clientSelection: pending,\n      autoScrollMode: 'FLUID'\n    });\n  };\n\n  var stopDragging = function stopDragging(fn) {\n    if (fn === void 0) {\n      fn = noop$2;\n    }\n\n    schedule.cancel();\n    touchStartMarshal.reset();\n    webkitHack.releaseTouchMove();\n    unbindWindowEvents();\n    postDragEventPreventer.preventNext();\n    setState(initial);\n    fn();\n  };\n\n  var startPendingDrag = function startPendingDrag(event) {\n    var touch = event.touches[0];\n    var clientX = touch.clientX,\n        clientY = touch.clientY;\n    var point = {\n      x: clientX,\n      y: clientY\n    };\n    var longPressTimerId = setTimeout(startDragging, timeForLongPress);\n    setState({\n      longPressTimerId: longPressTimerId,\n      pending: point,\n      isDragging: false,\n      hasMoved: false\n    });\n    bindWindowEvents();\n  };\n\n  var stopPendingDrag = function stopPendingDrag() {\n    if (state.longPressTimerId) {\n      clearTimeout(state.longPressTimerId);\n    }\n\n    schedule.cancel();\n    touchStartMarshal.reset();\n    webkitHack.releaseTouchMove();\n    unbindWindowEvents();\n    setState(initial);\n  };\n\n  var kill = function kill(fn) {\n    if (fn === void 0) {\n      fn = noop$2;\n    }\n\n    if (state.pending) {\n      stopPendingDrag();\n      return;\n    }\n\n    stopDragging(fn);\n  };\n\n  var unmount = function unmount() {\n    kill();\n    postDragEventPreventer.abort();\n  };\n\n  var cancel = function cancel() {\n    kill(callbacks.onCancel);\n  };\n\n  var windowBindings = [{\n    eventName: 'touchmove',\n    options: {\n      passive: false\n    },\n    fn: function fn(event) {\n      if (!state.isDragging) {\n        stopPendingDrag();\n        return;\n      }\n\n      if (!state.hasMoved) {\n        setState({\n          hasMoved: true\n        });\n      }\n\n      var _event$touches$ = event.touches[0],\n          clientX = _event$touches$.clientX,\n          clientY = _event$touches$.clientY;\n      var point = {\n        x: clientX,\n        y: clientY\n      };\n      event.preventDefault();\n      schedule.move(point);\n    }\n  }, {\n    eventName: 'touchend',\n    fn: function fn(event) {\n      if (!state.isDragging) {\n        stopPendingDrag();\n        return;\n      }\n\n      event.preventDefault();\n      stopDragging(callbacks.onDrop);\n    }\n  }, {\n    eventName: 'touchcancel',\n    fn: function fn(event) {\n      if (!state.isDragging) {\n        stopPendingDrag();\n        return;\n      }\n\n      event.preventDefault();\n      stopDragging(callbacks.onCancel);\n    }\n  }, {\n    eventName: 'touchstart',\n    fn: cancel\n  }, {\n    eventName: 'orientationchange',\n    fn: cancel\n  }, {\n    eventName: 'resize',\n    fn: cancel\n  }, {\n    eventName: 'scroll',\n    options: {\n      passive: true,\n      capture: false\n    },\n    fn: function fn() {\n      if (state.pending) {\n        stopPendingDrag();\n        return;\n      }\n\n      schedule.windowScrollMove();\n    }\n  }, {\n    eventName: 'contextmenu',\n    fn: function fn(event) {\n      event.preventDefault();\n    }\n  }, {\n    eventName: 'keydown',\n    fn: function fn(event) {\n      if (!state.isDragging) {\n        cancel();\n        return;\n      }\n\n      if (event.keyCode === escape) {\n        event.preventDefault();\n      }\n\n      cancel();\n    }\n  }, {\n    eventName: 'touchforcechange',\n    fn: function fn(event) {\n      if (state.hasMoved) {\n        event.preventDefault();\n        return;\n      }\n\n      var touch = event.touches[0];\n\n      if (touch.force >= forcePressThreshold) {\n        cancel();\n      }\n    }\n  }, {\n    eventName: supportedEventName,\n    fn: cancel\n  }];\n\n  var bindWindowEvents = function bindWindowEvents() {\n    bindEvents(getWindow(), windowBindings, {\n      capture: true\n    });\n  };\n\n  var unbindWindowEvents = function unbindWindowEvents() {\n    unbindEvents(getWindow(), windowBindings, {\n      capture: true\n    });\n  };\n\n  var onTouchStart = function onTouchStart(event) {\n    if (touchStartMarshal.isHandled()) {\n      return;\n    }\n\n    !!isCapturing() ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Should not be able to perform a touch start while a drag or pending drag is occurring') : invariant(false) : void 0;\n\n    if (!canStartCapturing(event)) {\n      return;\n    }\n\n    touchStartMarshal.handle();\n    webkitHack.preventTouchMove();\n    startPendingDrag(event);\n  };\n\n  var sensor = {\n    onTouchStart: onTouchStart,\n    kill: kill,\n    isCapturing: isCapturing,\n    isDragging: isDragging,\n    unmount: unmount\n  };\n  return sensor;\n};\n\nvar _DragHandle$contextTy;\n\nvar preventHtml5Dnd = function preventHtml5Dnd(event) {\n  event.preventDefault();\n};\n\nvar DragHandle = function (_Component) {\n  _inheritsLoose(DragHandle, _Component);\n\n  function DragHandle(props, context) {\n    var _this;\n\n    _this = _Component.call(this, props, context) || this;\n    _this.mouseSensor = void 0;\n    _this.keyboardSensor = void 0;\n    _this.touchSensor = void 0;\n    _this.sensors = void 0;\n    _this.styleContext = void 0;\n    _this.canLift = void 0;\n    _this.isFocused = false;\n    _this.lastDraggableRef = void 0;\n\n    _this.onFocus = function () {\n      _this.isFocused = true;\n    };\n\n    _this.onBlur = function () {\n      _this.isFocused = false;\n    };\n\n    _this.onKeyDown = function (event) {\n      if (_this.mouseSensor.isCapturing() || _this.touchSensor.isCapturing()) {\n        return;\n      }\n\n      _this.keyboardSensor.onKeyDown(event);\n    };\n\n    _this.onMouseDown = function (event) {\n      if (_this.keyboardSensor.isCapturing() || _this.mouseSensor.isCapturing()) {\n        return;\n      }\n\n      _this.mouseSensor.onMouseDown(event);\n    };\n\n    _this.onTouchStart = function (event) {\n      if (_this.mouseSensor.isCapturing() || _this.keyboardSensor.isCapturing()) {\n        return;\n      }\n\n      _this.touchSensor.onTouchStart(event);\n    };\n\n    _this.canStartCapturing = function (event) {\n      if (_this.isAnySensorCapturing()) {\n        return false;\n      }\n\n      if (!_this.canLift(_this.props.draggableId)) {\n        return false;\n      }\n\n      return shouldAllowDraggingFromTarget(event, _this.props);\n    };\n\n    _this.isAnySensorCapturing = function () {\n      return _this.sensors.some(function (sensor) {\n        return sensor.isCapturing();\n      });\n    };\n\n    _this.getProvided = memoizeOne(function (isEnabled) {\n      if (!isEnabled) {\n        return null;\n      }\n\n      var provided = {\n        onMouseDown: _this.onMouseDown,\n        onKeyDown: _this.onKeyDown,\n        onTouchStart: _this.onTouchStart,\n        onFocus: _this.onFocus,\n        onBlur: _this.onBlur,\n        tabIndex: 0,\n        'data-react-beautiful-dnd-drag-handle': _this.styleContext,\n        'aria-roledescription': 'Draggable item. Press space bar to lift',\n        draggable: false,\n        onDragStart: preventHtml5Dnd\n      };\n      return provided;\n    });\n\n    var getWindow = function getWindow() {\n      return getWindowFromRef(_this.props.getDraggableRef());\n    };\n\n    var args = {\n      callbacks: _this.props.callbacks,\n      getDraggableRef: _this.props.getDraggableRef,\n      getWindow: getWindow,\n      canStartCapturing: _this.canStartCapturing\n    };\n    _this.mouseSensor = createMouseSensor(args);\n    _this.keyboardSensor = createKeyboardSensor(args);\n    _this.touchSensor = createTouchSensor(args);\n    _this.sensors = [_this.mouseSensor, _this.keyboardSensor, _this.touchSensor];\n    _this.styleContext = context[styleContextKey];\n    _this.canLift = context[canLiftContextKey];\n    return _this;\n  }\n\n  var _proto = DragHandle.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    var draggableRef = this.props.getDraggableRef();\n    this.lastDraggableRef = draggableRef;\n    !draggableRef ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot get draggable ref from drag handle') : invariant(false) : void 0;\n\n    if (!this.props.isEnabled) {\n      return;\n    }\n\n    var dragHandleRef = getDragHandleRef(draggableRef);\n    retainer.tryRestoreFocus(this.props.draggableId, dragHandleRef);\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {\n    var _this2 = this;\n\n    var ref = this.props.getDraggableRef();\n\n    if (ref !== this.lastDraggableRef) {\n      this.lastDraggableRef = ref;\n\n      if (!ref || !this.isFocused) {\n        return;\n      }\n\n      if (!this.props.isEnabled) {\n        return;\n      }\n\n      getDragHandleRef(ref).focus();\n    }\n\n    var isCapturing = this.isAnySensorCapturing();\n\n    if (!isCapturing) {\n      return;\n    }\n\n    var isDragStopping = prevProps.isDragging && !this.props.isDragging;\n\n    if (isDragStopping) {\n      this.sensors.forEach(function (sensor) {\n        if (sensor.isCapturing()) {\n          sensor.kill();\n        }\n      });\n    }\n\n    if (this.props.isEnabled) {\n      return;\n    }\n\n    this.sensors.forEach(function (sensor) {\n      if (!sensor.isCapturing()) {\n        return;\n      }\n\n      var wasDragging = sensor.isDragging();\n      sensor.kill();\n\n      if (wasDragging) {\n        if (process.env.NODE_ENV !== 'production') {\n          console.warn('You have disabled dragging on a Draggable while it was dragging. The drag has been cancelled');\n        }\n\n        _this2.props.callbacks.onCancel();\n      }\n    });\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    var _this3 = this;\n\n    this.sensors.forEach(function (sensor) {\n      var wasDragging = sensor.isDragging();\n      sensor.unmount();\n\n      if (wasDragging) {\n        _this3.props.callbacks.onCancel();\n      }\n    });\n\n    var shouldRetainFocus = function () {\n      if (!_this3.props.isEnabled) {\n        return false;\n      }\n\n      if (!_this3.isFocused) {\n        return false;\n      }\n\n      return _this3.props.isDragging || _this3.props.isDropAnimating;\n    }();\n\n    if (shouldRetainFocus) {\n      retainer.retain(this.props.draggableId);\n    }\n  };\n\n  _proto.render = function render() {\n    var _this$props = this.props,\n        children = _this$props.children,\n        isEnabled = _this$props.isEnabled;\n    return children(this.getProvided(isEnabled));\n  };\n\n  return DragHandle;\n}(Component);\n\nDragHandle.contextTypes = (_DragHandle$contextTy = {}, _DragHandle$contextTy[styleContextKey] = PropTypes.string.isRequired, _DragHandle$contextTy[canLiftContextKey] = PropTypes.func.isRequired, _DragHandle$contextTy);\n\nvar getWindowScroll = function getWindowScroll() {\n  return {\n    x: window.pageXOffset,\n    y: window.pageYOffset\n  };\n};\n\nvar getViewport = function getViewport() {\n  var scroll = getWindowScroll();\n  var top = scroll.y;\n  var left = scroll.x;\n  var doc = document.documentElement;\n  !doc ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Could not find document.documentElement') : invariant(false) : void 0;\n  var width = doc.clientWidth;\n  var height = doc.clientHeight;\n  var right = left + width;\n  var bottom = top + height;\n  var frame = getRect({\n    top: top,\n    left: left,\n    right: right,\n    bottom: bottom\n  });\n  var maxScroll = getMaxScroll({\n    scrollHeight: doc.scrollHeight,\n    scrollWidth: doc.scrollWidth,\n    width: frame.width,\n    height: frame.height\n  });\n  var viewport = {\n    frame: frame,\n    scroll: {\n      initial: scroll,\n      current: scroll,\n      max: maxScroll,\n      diff: {\n        value: origin,\n        displacement: origin\n      }\n    }\n  };\n  return viewport;\n};\n\nvar _Draggable$contextTyp;\n\nvar zIndexOptions = {\n  dragging: 5000,\n  dropAnimating: 4500\n};\n\nvar getTranslate = function getTranslate(offset) {\n  if (isEqual(offset, origin)) {\n    return null;\n  }\n\n  return \"translate(\" + offset.x + \"px, \" + offset.y + \"px)\";\n};\n\nvar getSpeed$1 = function getSpeed(isDragging, shouldAnimateDragMovement, isDropAnimating) {\n  if (isDropAnimating) {\n    return 'STANDARD';\n  }\n\n  if (isDragging && shouldAnimateDragMovement) {\n    return 'FAST';\n  }\n\n  return 'INSTANT';\n};\n\nvar Draggable = function (_Component) {\n  _inheritsLoose(Draggable, _Component);\n\n  function Draggable(props, context) {\n    var _this;\n\n    _this = _Component.call(this, props, context) || this;\n    _this.callbacks = void 0;\n    _this.styleContext = void 0;\n    _this.ref = null;\n\n    _this.onMoveEnd = function () {\n      if (_this.props.isDropAnimating) {\n        _this.props.dropAnimationFinished();\n      }\n    };\n\n    _this.onLift = function (options) {\n      start('LIFT');\n      var ref = _this.ref;\n      !ref ? process.env.NODE_ENV !== \"production\" ? invariant(false) : invariant(false) : void 0;\n      !!_this.props.isDragDisabled ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Cannot lift a Draggable when it is disabled') : invariant(false) : void 0;\n      var clientSelection = options.clientSelection,\n          autoScrollMode = options.autoScrollMode;\n      var _this$props = _this.props,\n          lift = _this$props.lift,\n          draggableId = _this$props.draggableId;\n      var client = {\n        selection: clientSelection,\n        borderBoxCenter: getBorderBoxCenterPosition(ref),\n        offset: origin\n      };\n      lift({\n        id: draggableId,\n        client: client,\n        autoScrollMode: autoScrollMode,\n        viewport: getViewport()\n      });\n      finish('LIFT');\n    };\n\n    _this.setRef = function (ref) {\n      if (ref === null) {\n        return;\n      }\n\n      if (ref === _this.ref) {\n        return;\n      }\n\n      _this.ref = ref;\n      throwIfRefIsInvalid(ref);\n    };\n\n    _this.getDraggableRef = function () {\n      return _this.ref;\n    };\n\n    _this.getDraggingStyle = memoizeOne(function (change, dimension, isDropAnimating) {\n      var box = dimension.client;\n      var style = {\n        position: 'fixed',\n        top: box.marginBox.top,\n        left: box.marginBox.left,\n        boxSizing: 'border-box',\n        width: box.borderBox.width,\n        height: box.borderBox.height,\n        transition: 'none',\n        zIndex: isDropAnimating ? zIndexOptions.dropAnimating : zIndexOptions.dragging,\n        transform: getTranslate(change),\n        pointerEvents: 'none'\n      };\n      return style;\n    });\n    _this.getNotDraggingStyle = memoizeOne(function (current, shouldAnimateDisplacement) {\n      var style = {\n        transform: getTranslate(current),\n        transition: shouldAnimateDisplacement ? null : 'none'\n      };\n      return style;\n    });\n    _this.getProvided = memoizeOne(function (change, isDragging, isDropAnimating, shouldAnimateDisplacement, dimension, dragHandleProps) {\n      var useDraggingStyle = isDragging || isDropAnimating;\n\n      var draggableStyle = function () {\n        if (!useDraggingStyle) {\n          return _this.getNotDraggingStyle(change, shouldAnimateDisplacement);\n        }\n\n        !dimension ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'draggable dimension required for dragging') : invariant(false) : void 0;\n        return _this.getDraggingStyle(change, dimension, isDropAnimating);\n      }();\n\n      var provided = {\n        innerRef: _this.setRef,\n        draggableProps: {\n          'data-react-beautiful-dnd-draggable': _this.styleContext,\n          style: draggableStyle\n        },\n        dragHandleProps: dragHandleProps\n      };\n      return provided;\n    });\n    _this.getSnapshot = memoizeOne(function (isDragging, isDropAnimating, draggingOver) {\n      return {\n        isDragging: isDragging || isDropAnimating,\n        isDropAnimating: isDropAnimating,\n        draggingOver: draggingOver\n      };\n    });\n\n    _this.renderChildren = function (change, dragHandleProps) {\n      var _this$props2 = _this.props,\n          isDragging = _this$props2.isDragging,\n          isDropAnimating = _this$props2.isDropAnimating,\n          dimension = _this$props2.dimension,\n          draggingOver = _this$props2.draggingOver,\n          shouldAnimateDisplacement = _this$props2.shouldAnimateDisplacement,\n          children = _this$props2.children;\n      var child = children(_this.getProvided(change, isDragging, isDropAnimating, shouldAnimateDisplacement, dimension, dragHandleProps), _this.getSnapshot(isDragging, isDropAnimating, draggingOver));\n      var isDraggingOrDropping = isDragging || isDropAnimating;\n\n      var placeholder = function () {\n        if (!isDraggingOrDropping) {\n          return null;\n        }\n\n        !dimension ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Draggable: Dimension is required for dragging') : invariant(false) : void 0;\n        return React.createElement(Placeholder, {\n          placeholder: dimension.placeholder\n        });\n      }();\n\n      return React.createElement(Fragment, null, child, placeholder);\n    };\n\n    var callbacks = {\n      onLift: _this.onLift,\n      onMove: function onMove(clientSelection) {\n        return props.move({\n          client: clientSelection,\n          shouldAnimate: false\n        });\n      },\n      onDrop: function onDrop() {\n        return props.drop({\n          reason: 'DROP'\n        });\n      },\n      onCancel: function onCancel() {\n        return props.drop({\n          reason: 'CANCEL'\n        });\n      },\n      onMoveUp: props.moveUp,\n      onMoveDown: props.moveDown,\n      onMoveRight: props.moveRight,\n      onMoveLeft: props.moveLeft,\n      onWindowScroll: function onWindowScroll() {\n        return props.moveByWindowScroll({\n          scroll: getWindowScroll()\n        });\n      }\n    };\n    _this.callbacks = callbacks;\n    _this.styleContext = context[styleContextKey];\n    return _this;\n  }\n\n  var _proto = Draggable.prototype;\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.ref = null;\n  };\n\n  _proto.render = function render() {\n    var _this2 = this;\n\n    var _this$props3 = this.props,\n        draggableId = _this$props3.draggableId,\n        index = _this$props3.index,\n        offset = _this$props3.offset,\n        isDragging = _this$props3.isDragging,\n        isDropAnimating = _this$props3.isDropAnimating,\n        isDragDisabled = _this$props3.isDragDisabled,\n        shouldAnimateDragMovement = _this$props3.shouldAnimateDragMovement,\n        disableInteractiveElementBlocking = _this$props3.disableInteractiveElementBlocking;\n    var droppableId = this.context[droppableIdKey];\n    var type = this.context[droppableTypeKey];\n    var speed = getSpeed$1(isDragging, shouldAnimateDragMovement, isDropAnimating);\n    return React.createElement(DraggableDimensionPublisher, {\n      key: draggableId,\n      draggableId: draggableId,\n      droppableId: droppableId,\n      type: type,\n      index: index,\n      getDraggableRef: this.getDraggableRef\n    }, React.createElement(Moveable, {\n      speed: speed,\n      destination: offset,\n      onMoveEnd: this.onMoveEnd\n    }, function (change) {\n      return React.createElement(DragHandle, {\n        draggableId: draggableId,\n        isDragging: isDragging,\n        isDropAnimating: isDropAnimating,\n        isEnabled: !isDragDisabled,\n        callbacks: _this2.callbacks,\n        getDraggableRef: _this2.getDraggableRef,\n        canDragInteractiveElements: disableInteractiveElementBlocking\n      }, function (dragHandleProps) {\n        return _this2.renderChildren(change, dragHandleProps);\n      });\n    }));\n  };\n\n  return Draggable;\n}(Component);\n\nDraggable.contextTypes = (_Draggable$contextTyp = {}, _Draggable$contextTyp[droppableIdKey] = PropTypes.string.isRequired, _Draggable$contextTyp[droppableTypeKey] = PropTypes.string.isRequired, _Draggable$contextTyp[styleContextKey] = PropTypes.string.isRequired, _Draggable$contextTyp);\nvar defaultMapProps = {\n  isDropAnimating: false,\n  isDragging: false,\n  offset: origin,\n  shouldAnimateDragMovement: false,\n  shouldAnimateDisplacement: true,\n  dimension: null,\n  draggingOver: null\n};\n\nvar makeMapStateToProps$1 = function makeMapStateToProps() {\n  var memoizedOffset = memoizeOne(function (x, y) {\n    return {\n      x: x,\n      y: y\n    };\n  });\n  var getNotDraggingProps = memoizeOne(function (offset, shouldAnimateDisplacement) {\n    return {\n      isDropAnimating: false,\n      isDragging: false,\n      offset: offset,\n      shouldAnimateDisplacement: shouldAnimateDisplacement,\n      shouldAnimateDragMovement: false,\n      dimension: null,\n      draggingOver: null\n    };\n  });\n  var getDraggingProps = memoizeOne(function (offset, shouldAnimateDragMovement, dimension, draggingOver) {\n    return {\n      isDragging: true,\n      isDropAnimating: false,\n      shouldAnimateDisplacement: false,\n      offset: offset,\n      shouldAnimateDragMovement: shouldAnimateDragMovement,\n      dimension: dimension,\n      draggingOver: draggingOver\n    };\n  });\n\n  var getOutOfTheWayMovement = function getOutOfTheWayMovement(id, movement) {\n    var map = getDisplacementMap(movement.displaced);\n    var displacement = map[id];\n\n    if (!displacement) {\n      return null;\n    }\n\n    if (!displacement.isVisible) {\n      return null;\n    }\n\n    var amount = movement.isBeyondStartPosition ? negate(movement.amount) : movement.amount;\n    return getNotDraggingProps(memoizedOffset(amount.x, amount.y), displacement.shouldAnimate);\n  };\n\n  var draggingSelector = function draggingSelector(state, ownProps) {\n    if (state.isDragging) {\n      if (state.critical.draggable.id !== ownProps.draggableId) {\n        return null;\n      }\n\n      var offset = state.current.client.offset;\n      var dimension = state.dimensions.draggables[ownProps.draggableId];\n      var shouldAnimateDragMovement = state.shouldAnimate;\n      var draggingOver = state.impact.destination ? state.impact.destination.droppableId : null;\n      return getDraggingProps(memoizedOffset(offset.x, offset.y), shouldAnimateDragMovement, dimension, draggingOver);\n    }\n\n    if (state.phase === 'DROP_ANIMATING') {\n      var pending = state.pending;\n\n      if (pending.result.draggableId !== ownProps.draggableId) {\n        return null;\n      }\n\n      var _draggingOver = pending.result.destination ? pending.result.destination.droppableId : null;\n\n      return {\n        isDragging: false,\n        isDropAnimating: true,\n        offset: pending.newHomeOffset,\n        dimension: state.dimensions.draggables[ownProps.draggableId],\n        draggingOver: _draggingOver,\n        shouldAnimateDragMovement: false,\n        shouldAnimateDisplacement: false\n      };\n    }\n\n    return null;\n  };\n\n  var movingOutOfTheWaySelector = function movingOutOfTheWaySelector(state, ownProps) {\n    if (state.isDragging) {\n      if (state.critical.draggable.id === ownProps.draggableId) {\n        return null;\n      }\n\n      return getOutOfTheWayMovement(ownProps.draggableId, state.impact.movement);\n    }\n\n    if (state.phase === 'DROP_ANIMATING') {\n      if (state.pending.result.draggableId === ownProps.draggableId) {\n        return null;\n      }\n\n      return getOutOfTheWayMovement(ownProps.draggableId, state.pending.impact.movement);\n    }\n\n    return null;\n  };\n\n  var selector = function selector(state, ownProps) {\n    var dragging = draggingSelector(state, ownProps);\n\n    if (dragging) {\n      return dragging;\n    }\n\n    var movingOutOfTheWay = movingOutOfTheWaySelector(state, ownProps);\n\n    if (movingOutOfTheWay) {\n      return movingOutOfTheWay;\n    }\n\n    return defaultMapProps;\n  };\n\n  return selector;\n};\n\nvar mapDispatchToProps = {\n  lift: lift,\n  move: move,\n  moveUp: moveUp,\n  moveDown: moveDown,\n  moveLeft: moveLeft,\n  moveRight: moveRight,\n  moveByWindowScroll: moveByWindowScroll,\n  drop: drop,\n  dropAnimationFinished: dropAnimationFinished\n};\nvar ConnectedDraggable = connect(makeMapStateToProps$1, mapDispatchToProps, null, {\n  storeKey: storeKey,\n  pure: true,\n  areStatePropsEqual: isStrictEqual\n})(Draggable);\nConnectedDraggable.defaultProps = {\n  isDragDisabled: false,\n  disableInteractiveElementBlocking: false\n};\nexport { DragDropContext, connectedDroppable as Droppable, ConnectedDraggable as Draggable, resetServerContext };","map":null,"metadata":{},"sourceType":"module"}